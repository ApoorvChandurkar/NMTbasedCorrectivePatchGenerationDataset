SocketAndStreams sockAndStreams = null ;
sockAndStreams = socketCache . get ( arg ) ;
ss = secureResources . getStreamingSocket ( arg ) ;
ss . close ( arg ) ;
String user = getRenewerForToken ( arg ) ;
String user = getRenewerForToken ( arg ) ;
blockReader . close ( arg ) ;
reader . close ( arg ) ;
Peer peer = null ;
peer = peerCache . get ( arg ) ;
tcpPeerServer = new TcpPeerServer ( arg ) ;
IOUtils . cleanup ( arg ) ;
IOUtils . cleanup ( arg ) ;
throw new ClosedChannelException ( arg ) ;
builder . setToken ( arg ) ;
if ( token == null ) builder . clearToken ( arg ) ;
builder . setToken ( arg ) ;
if ( token == null ) builder . clearToken ( arg ) ;
return p . getNewExpiryTime ( arg ) ;
builder . setNewExpiryTime ( arg ) ;
builder . setToken ( arg ) ;
if ( token == null ) builder . clearToken ( arg ) ;
builder . setToken ( arg ) ;
if ( token == null ) builder . clearToken ( arg ) ;
return p . getNewExpiryTime ( arg ) ;
builder . setNewExpiryTime ( arg ) ;
return version != null ? version . branch ( arg ) : Unknown ;
return VersionInfo . getVersion ( arg ) +  from  + VersionInfo . getRevision ( arg ) +  by  + VersionInfo . getUser ( arg ) +  source checksum  + VersionInfo . getSrcChecksum ( arg ) ;
return version != null ? version . date ( arg ) : Unknown ;
return version != null ? version . revision ( arg ) : Unknown ;
return version != null ? version . srcChecksum ( arg ) : Unknown ;
return version != null ? version . url ( arg ) : Unknown ;
return version != null ? version . user ( arg ) : Unknown ;
return version != null ? version . version ( arg ) : Unknown ;
return version != null ? version . branch ( arg ) : Unknown ;
return YarnVersionInfo . getVersion ( arg ) +  from  + YarnVersionInfo . getRevision ( arg ) +  by  + YarnVersionInfo . getUser ( arg ) +  source checksum  + YarnVersionInfo . getSrcChecksum ( arg ) ;
return version != null ? version . date ( arg ) : Unknown ;
return version != null ? version . revision ( arg ) : Unknown ;
return version != null ? version . srcChecksum ( arg ) : Unknown ;
return version != null ? version . url ( arg ) : Unknown ;
return version != null ? version . user ( arg ) : Unknown ;
return version != null ? version . version ( arg ) : Unknown ;
return COMMON_VERSION_INFO . _getBranch ( arg ) ;
return COMMON_VERSION_INFO . _getDate ( arg ) ;
return COMMON_VERSION_INFO . _getRevision ( arg ) ;
return COMMON_VERSION_INFO . _getSrcChecksum ( arg ) ;
return COMMON_VERSION_INFO . _getUrl ( arg ) ;
return COMMON_VERSION_INFO . _getUser ( arg ) ;
return COMMON_VERSION_INFO . _getVersion ( arg ) ;
return YARN_VERSION_INFO . _getBranch ( arg ) ;
return YARN_VERSION_INFO . _getDate ( arg ) ;
return YARN_VERSION_INFO . _getRevision ( arg ) ;
return YARN_VERSION_INFO . _getSrcChecksum ( arg ) ;
return YARN_VERSION_INFO . _getUrl ( arg ) ;
return YARN_VERSION_INFO . _getUser ( arg ) ;
return YARN_VERSION_INFO . _getVersion ( arg ) ;
Iterator < Entry < Key , Value >> iter = multimap . entries ( arg ) . iterator ( arg ) ;
Entry < Key , Value > entry = iter . next ( arg ) ;
PeerCache cache = new PeerCache ( arg ) ;
cache . close ( arg ) ;
PeerCache cache = new PeerCache ( arg ) ;
HashMultiset < FakePeer > peers = HashMultiset . create ( arg ) ;
cache . close ( arg ) ;
PeerCache cache = new PeerCache ( arg ) ;
cache . close ( arg ) ;
PeerCache cache = new PeerCache ( arg ) ;
cache . close ( arg ) ;
file = file . recordModification ( arg ) ;
if ( conf . domainSocketPath . isEmpty ( arg ) ) return null ;
final ChildrenDiff combined = new ChildrenDiff ( arg ) ;
combined . combinePosterior ( arg ) ;
ChildrenDiff diff = dirNode . getLastSnapshotDiff ( arg ) . getDiff ( arg ) ;
ChildrenDiff diff = dirNode . getLastSnapshotDiff ( arg ) . getDiff ( arg ) ;
totalBytes += segmentsToMerge . get ( arg ) . getLength ( arg ) ;
totalBytes-= inputBytesOfThisMerge - tempSegment . getLength ( arg ) ;
List < Path > disk = new ArrayList < Path > ( arg ) ;
FileWithSnapshot deletedWithLink = ( FileWithSnapshot ) deleted ;
( ( INodeFile ) deleted ) . setBlocks ( arg ) ;
totalBytes += segmentsToMerge . get ( arg ) . getRawDataLength ( arg ) ;
totalBytes-= inputBytesOfThisMerge - tempSegment . getRawDataLength ( arg ) ;
List < CompressAwarePath > disk = new ArrayList < CompressAwarePath > ( arg ) ;
sdir . getDiffs ( arg ) . deleteSnapshotDiff ( arg ) ;
int laterDiffIndex = size ;
DirectoryDiff sdiff = difflist . get ( arg ) ;
diffs . checkAndAddLatestSnapshotDiff ( arg ) . checkAndInitINode ( arg ) ;
List < DirectoryDiff > diffs = sNode . getDiffs ( arg ) . asList ( arg ) ;
DirectoryDiff sdiff = diffs . get ( arg ) ;
ChildrenDiff diff = dirNode . getDiffs ( arg ) . getLast ( arg ) . getChildrenDiff ( arg ) ;
diff = dirNode . getDiffs ( arg ) . getLast ( arg ) . getChildrenDiff ( arg ) ;
diff = dirNode . getDiffs ( arg ) . getLast ( arg ) . getChildrenDiff ( arg ) ;
ChildrenDiff diff = dirNode . getDiffs ( arg ) . getLast ( arg ) . getChildrenDiff ( arg ) ;
diff = dirNode . getDiffs ( arg ) . getLast ( arg ) . getChildrenDiff ( arg ) ;
diff = dirNode . getDiffs ( arg ) . getLast ( arg ) . getChildrenDiff ( arg ) ;
( ( INodeFile ) inode ) . destroySubtreeAndCollectBlocks ( arg ) ;
result [ i ] = PBHelper . convert ( arg ) ;
SnapshotDiffInfo diffs = null ;
return diffs != null ? diffs . generateReport ( arg ) : new SnapshotDiffReport ( arg ) ;
SnapshotDiffInfo diffs = new SnapshotDiffInfo ( arg ) ;
namenode . getNamesystem ( arg ) . getBlockManager ( arg ) . getDatanodeManager ( arg ) . setNumStaleNodes ( arg ) ;
namenode . getNamesystem ( arg ) . getBlockManager ( arg ) . getDatanodeManager ( arg ) . setNumStaleNodes ( arg ) ;
INodeDirectory parent = oldnode . getParent ( arg ) ;
return snapshottable ? new INodeDirectorySnapshottable ( arg ) : ( withSnapshot ? new INodeDirectoryWithSnapshot ( arg ) : dir ) ;
return latest == null ? this : parent . replaceChild4INodeFileWithSnapshot ( arg ) . recordModification ( arg ) ;
return null ;
return getClass ( arg ) . getSimpleName ( arg ) + :  + diffs ;
int n = destroySubtreeAndCollectBlocksRecursively ( arg ) ;
DirectoryDiff sdiff = new DirectoryDiff ( arg ) ;
parentWithSnapshot . getDiffs ( arg ) . addFirst ( arg ) ;
INodeFile nodeInCreated = ( INodeFile ) diff . searchCreated ( arg ) ;
INodeFile nodeInDeleted = ( INodeFile ) diff . searchDeleted ( arg ) ;
nodeInCreated = ( INodeFile ) diff . searchCreated ( arg ) ;
nodeInCreated = ( INodeFile ) diff . searchCreated ( arg ) ;
fsdir . getINode ( arg ) . dumpTreeRecursively ( arg ) ;
fsdir . getINode ( arg ) . dumpTreeRecursively ( arg ) ;
fsdir . getINode ( arg ) . dumpTreeRecursively ( arg ) ;
return is64Bit ? com.ibm.security.auth.module.AIX64LoginModule : com.ibm.security.auth.module.AIXLoginModule ;
final INodeDirectorySnapshottable snapshottableParent = INodeDirectorySnapshottable . valueOf ( arg ) ;
final INode root = loadINode ( arg ) ;
return isInLatestSnapshot ( arg ) ? replaceSelf4INodeDirectoryWithSnapshot ( arg ) . recordModification ( arg ) : this ;
return isInLatestSnapshot ( arg ) ? parent . replaceChild4INodeFileWithSnapshot ( arg ) . recordModification ( arg ) : this ;
return isInLatestSnapshot ( arg ) ? parent . replaceChild4INodeFileUcWithSnapshot ( arg ) . recordModification ( arg ) : this ;
return isInLatestSnapshot ( arg ) ? parent . saveChild2Snapshot ( arg ) : this ;
final DirectoryDiff d = getDiffs ( arg ) . addDiff ( arg ) ;
return isInLatestSnapshot ( arg ) ? saveSelf2Snapshot ( arg ) : this ;
isCurrentFileDeleted = true ;
isCurrentFileDeleted = true ;
status . reference ( arg ) ;
status . unreference ( arg ) ;
status . reference ( arg ) ;
status . unreference ( arg ) ;
status . reference ( arg ) ;
status . unreference ( arg ) ;
status . reference ( arg ) ;
status . unreference ( arg ) ;
status . reference ( arg ) ;
status . unreference ( arg ) ;
status . reference ( arg ) ;
status . unreference ( arg ) ;
status . reference ( arg ) ;
status . unreference ( arg ) ;
refCount = status . getReferenceCount ( arg ) ;
status . reference ( arg ) ;
status . unreference ( arg ) ;
status . reference ( arg ) ;
status . unreference ( arg ) ;
FileDescriptor descriptors [ ] = new FileDescriptor [ streams . length ] ;
status . reference ( arg ) ;
status . unreference ( arg ) ;
status . reference ( arg ) ;
status . unreference ( arg ) ;
status . reference ( arg ) ;
status . unreference ( arg ) ;
return this instanceof FileWithSnapshot ? Util . getBlockReplication ( arg ) : getFileReplication ( arg ) ;
final long fileId = m . containsKey ( arg ) ? ( Long ) m . get ( arg ) : INodeId . GRANDFATHER_INODE_ID ;
snapshotName = args . removeLast ( arg ) ;
replaceChildFile ( arg ) ;
replaceChildFile ( arg ) ;
INodeFile . valueOf ( arg ) ;
updateCountForQuotaRecursively ( arg ) ;
nodeToUpdate . setAccessTime ( arg ) ;
nodeToUpdate . setModificationTime ( arg ) ;
clearChildren ( arg ) ;
Preconditions . checkNotNull ( arg ) ;
Preconditions . checkNotNull ( arg ) ;
copy . clearChildren ( arg ) ;
total += diffs . clear ( arg ) ;
final INodeDirectory parent = pathComponents [ pos - 1 ] . asDirectory ( arg ) ;
Preconditions . checkState ( arg ) ;
final INodeDirectory copy = currentDir . isQuotaSet ( arg ) ? new INodeDirectoryWithQuota ( arg ) : new INodeDirectory ( arg ) ;
final INodeFile snapshotINode = in . readBoolean ( arg ) ? loader . loadINodeWithLocalName ( arg ) . asFile ( arg ) : null ;
return in . readBoolean ( arg ) ? loader . loadINodeWithLocalName ( arg ) . asDirectory ( arg ) : null ;
Token < ? > token = null ;
String tokenString = webhdfs . getDelegationToken ( arg ) . encodeToUrlString ( arg ) ;
String tokenString = webhdfs . getDelegationToken ( arg ) . encodeToUrlString ( arg ) ;
return isInLatestSnapshot ( arg ) ? getParent ( arg ) . replaceChild4INodeFileWithSnapshot ( arg ) . recordModification ( arg ) : this ;
return isInLatestSnapshot ( arg ) ? getParent ( arg ) . replaceChild4INodeFileUcWithSnapshot ( arg ) . recordModification ( arg ) : this ;
return isInLatestSnapshot ( arg ) ? getParent ( arg ) . saveChild2Snapshot ( arg ) : this ;
final long filesRemoved ;
node . addSpaceConsumed2Cache ( arg ) ;
child . destroyAndCollectBlocks ( arg ) ;
( ( FileWithSnapshot ) this ) . getDiffs ( arg ) . clear ( arg ) ;
currentINode . addSpaceConsumed ( arg ) ;
Quota . Counts counts = Quota . Counts . newInstance ( arg ) ;
counts . add ( arg ) ;
counts . add ( arg ) ;
return counts ;
c . destroyAndCollectBlocks ( arg ) ;
Quota . Counts counts = Quota . Counts . newInstance ( arg ) ;
return counts ;
lastDiff . diff . destroyCreatedList ( arg ) ;
diff . destroyDiffAndCollectBlocks ( arg ) ;
deletedProcesser . process ( arg ) ;
deletedProcesser . process ( arg ) ;
final INodeWithAdditionalFields newNode = loadINode ( arg ) ;
final INodeWithAdditionalFields root = loadINode ( arg ) ;
clear ( arg ) ;
clear ( arg ) ;
removed . snapshotINode . clear ( arg ) ;
final List < INode > createdList = getList ( arg ) ;
final List < INode > deletedList = getList ( arg ) ;
final List < INode > created = getList ( arg ) ;
final List < INode > created = getList ( arg ) ;
final List < INode > deleted = getList ( arg ) ;
final int c = diff . searchIndex ( arg ) ;
final INode d = postDiff . getChildrenDiff ( arg ) . search ( arg ) ;
insert ( arg ) ;
insert ( arg ) ;
FSPermissionChecker pc = getPermissionChecker ( arg ) ;
return counts ;
return counts ;
counts . add ( arg ) ;
RegisterNodeManagerResponse regNMResponse ;
regNMResponse = this . resourceTracker . registerNodeManager ( arg ) ;
final long fileId = m . containsKey ( arg ) ? ( Long ) m . get ( arg ) : INodeId . GRANDFATHER_INODE_ID ;
SnapshotTestHelper . dumpTree ( arg ) ;
NodeHeartbeatResponse nodeHeartBeatResponse = YarnServerBuilderUtils . newNodeHeartbeatResponse ( arg ) ;
waitForEver = ( rmConnectWaitMS == null ) ;
ConcurrentMap < ContainerId , org . apache . hadoop . yarn . server . nodemanager . containermanager . container . Container > containers = getNMContext ( arg ) . getContainers ( arg ) ;
when ( arg ) . thenReturn ( arg ) ;
appAttempt . getSubmissionContext ( arg ) . setResource ( arg ) ;
return namenode . createSnapshot ( arg ) ;
return new Path ( arg ) ;
snapshotPath = snapshotManager . createSnapshot ( arg ) ;
return namesystem . createSnapshot ( arg ) ;
return getSnapshotPath ( arg ) ;
snapshotManager . removeSnapshottable ( arg ) ;
snapshottables . put ( arg ) ;
SchedulingPolicy defaultSchedPolicy = SchedulingPolicy . getDefault ( arg ) ;
schedulingMode = new FairSharePolicy ( arg ) ;
queue1 . setPolicy ( arg ) ;
ByteBuffer portInfo = response . getServiceResponse ( arg ) ;
startResp . setServiceResponse ( arg ) ;
startResp . setServiceResponse ( arg ) ;
startResp . setServiceResponse ( arg ) ;
startResp . setServiceResponse ( arg ) ;
response . addAllServiceResponse ( arg ) ;
File scriptFile = new File ( arg ) ;
File scriptFile = new File ( arg ) ;
allocateRequest . clearAsks ( arg ) ;
cacheDirectory = getAppFileCachePath ( arg ) ;
inode . cleanSubtree ( arg ) ;
ref . cleanSubtree ( arg ) ;
purgeLogsFrom = editLogs . get ( arg ) . getFirstTxId ( arg ) ;
int count = dn . getXceiverCount ( arg ) - 1 ;
this . mapCounters [ i ] = EMPTY_COUNTERS ;
this . reduceCounters = EMPTY_COUNTERS ;
out . write ( arg ) ;
WebServicesTestUtils . checkStringMatch ( arg ) ;
WebServicesTestUtils . checkStringMatch ( arg ) ;
Token < ApplicationTokenIdentifier > token = new Token < ApplicationTokenIdentifier > ( arg ) ;
amContainerEnv = request . getContainerLaunchContext ( arg ) . getEnvironment ( arg ) ;
WebServicesTestUtils . checkStringMatch ( arg ) ;
WebServicesTestUtils . checkStringMatch ( arg ) ;
addToInodeMapUnprotected ( arg ) ;
addToInodeMapUnprotected ( arg ) ;
purgeLogsFrom = editLogs . get ( arg ) . getLastTxId ( arg ) + 1 ;
int count = getXceiverCountWithoutServer ( arg ) ;
return new Counters ( arg ) ;
Counters current = new Counters ( arg ) ;
this . mapCounters [ i ] = new Counters ( arg ) ;
this . reduceCounters = new Counters ( arg ) ;
amTokens = request . getContainerLaunchContext ( arg ) . getContainerTokens ( arg ) ;
resyncWithRM ( arg ) ;
startContainer ( arg ) ;
FileUtil . setWritable ( arg ) ;
FileUtil . setWritable ( arg ) ;
if ( sd . getRoot ( arg ) . canRead ( arg ) && fsImage . exists ( arg ) ) return fsImage ;
data_fail . setWritable ( arg ) ;
failedDir . setWritable ( arg ) ;
currentDir . setExecutable ( arg ) ;
currentDir . setExecutable ( arg ) ;
currentDir . setExecutable ( arg ) ;
currentDir . setExecutable ( arg ) ;
currentDir . setExecutable ( arg ) ;
currentDir . setExecutable ( arg ) ;
dir . setWritable ( arg ) ;
dir . setWritable ( arg ) ;
logDir . setWritable ( arg ) ;
logDir . setWritable ( arg ) ;
sd0 . setExecutable ( arg ) ;
sd0 . setExecutable ( arg ) ;
sd0 . setExecutable ( arg ) ;
if ( FileUtil . canRead ( arg ) && fsImage . exists ( arg ) ) return fsImage ;
FileUtil . setWritable ( arg ) ;
FileUtil . setWritable ( arg ) ;
FileUtil . setExecutable ( arg ) ;
FileUtil . setExecutable ( arg ) ;
FileUtil . setExecutable ( arg ) ;
FileUtil . setExecutable ( arg ) ;
FileUtil . setExecutable ( arg ) ;
FileUtil . setExecutable ( arg ) ;
FileUtil . setWritable ( arg ) ;
FileUtil . setWritable ( arg ) ;
FileUtil . setWritable ( arg ) ;
FileUtil . setWritable ( arg ) ;
FileUtil . setExecutable ( arg ) ;
FileUtil . setExecutable ( arg ) ;
FileUtil . setExecutable ( arg ) ;
String user = null ;
asContext . setMaxAppAttempts ( arg ) ;
addToInodeMap ( arg ) ;
addToInodeMap ( arg ) ;
namesystem . dir . addToInodeMap ( arg ) ;
return new File ( arg ) ;
throw RPCUtil . unwrapAndThrowException ( arg ) ;
throw RPCUtil . unwrapAndThrowException ( arg ) ;
throw RPCUtil . unwrapAndThrowException ( arg ) ;
throw RPCUtil . unwrapAndThrowException ( arg ) ;
throw new IOException ( arg ) ;
throw unwrapAndThrowException ( arg ) ;
throw unwrapAndThrowException ( arg ) ;
throw unwrapAndThrowException ( arg ) ;
throw unwrapAndThrowException ( arg ) ;
throw unwrapAndThrowException ( arg ) ;
throw unwrapAndThrowException ( arg ) ;
throw unwrapAndThrowException ( arg ) ;
throw unwrapAndThrowException ( arg ) ;
throw unwrapAndThrowException ( arg ) ;
throw unwrapAndThrowException ( arg ) ;
throw unwrapAndThrowException ( arg ) ;
throw unwrapAndThrowException ( arg ) ;
throw unwrapAndThrowException ( arg ) ;
throw unwrapAndThrowException ( arg ) ;
throw new IOException ( arg ) ;
clc . setTokens ( arg ) ;
amTokens = request . getContainerLaunchContext ( arg ) . getTokens ( arg ) ;
final long delta = 50000 ;
return BuilderUtils . newContainerTokenIdentifier ( arg ) ;
ContainerLaunchContext container = ContainerLaunchContext . newInstance ( arg ) ;
ContainerLaunchContext container = ContainerLaunchContext . newInstance ( arg ) ;
container = Container . newInstance ( arg ) ;
return Resource . newInstance ( arg ) ;
return Resource . newInstance ( arg ) ;
Resource containerNeed = Resource . newInstance ( arg ) ;
return ApplicationReport . newInstance ( arg ) ;
ContainerLaunchContext amContainer = ContainerLaunchContext . newInstance ( arg ) ;
throw new HadoopIllegalArgumentException ( arg ) ;
Path file = fileContextTestHelper . getTestRootPath ( arg ) ;
startReq . setContainerToken ( arg ) ;
startRequest . setContainerToken ( arg ) ;
scRequest . setContainerToken ( arg ) ;
long pmemBytes = container . getResource ( arg ) . getMemory ( arg ) * 1024 * 1024L ;
request . setContainerToken ( arg ) ;
startRequest . setContainerToken ( arg ) ;
startRequest . setContainerToken ( arg ) ;
startRequest . setContainerToken ( arg ) ;
startRequest . setContainerToken ( arg ) ;
startRequest . setContainerToken ( arg ) ;
startRequest . setContainerToken ( arg ) ;
request . setContainerToken ( arg ) ;
return evt . getType ( arg ) == ContainersLauncherEventType . LAUNCH_CONTAINER && wcf . cId == evt . getContainer ( arg ) . getContainerId ( arg ) ;
startRequest . setContainerToken ( arg ) ;
return evt . getType ( arg ) == ContainerEventType . RESOURCE_LOCALIZED && c . getContainerId ( arg ) == evt . getContainerID ( arg ) ;
startRequest . setContainerToken ( arg ) ;
request . setContainerToken ( arg ) ;
startRequest . setContainerToken ( arg ) ;
testExpiredTokens ( arg ) ;
startRequest . setContainerToken ( arg ) ;
ApplicationAttemptId attemptId = ApplicationAttemptId . newInstance ( arg ) ;
ApplicationAttemptId attemptId = ApplicationAttemptId . newInstance ( arg ) ;
resourceManager = new AMRMClientAsync < ContainerRequest > ( arg ) ;
AMRMClientImpl < ContainerRequest > amClient = null ;
amClient = new AMRMClientImpl < ContainerRequest > ( arg ) ;
rmClient = new AMRMClientImpl < ContainerRequest > ( arg ) ;
Token containerToken = BuilderUtils . newContainerToken ( arg ) ;
return new TokenPBImpl ( arg ) ;
return new TokenPBImpl ( arg ) ;
return new TokenPBImpl ( arg ) ;
org . apache . hadoop . yarn . api . records . Token dToken = BuilderUtils . newDelegationToken ( arg ) ;
org . apache . hadoop . yarn . api . records . Token dToken = BuilderUtils . newDelegationToken ( arg ) ;
org . apache . hadoop . yarn . api . records . Token protoToken = request . getDelegationToken ( arg ) ;
org . apache . hadoop . yarn . api . records . Token protoToken = request . getDelegationToken ( arg ) ;
org . apache . hadoop . yarn . api . records . Token clientToken = application . getClientToken ( arg ) ;
org . apache . hadoop . yarn . api . records . Token mrDelegationToken ;
org . apache . hadoop . yarn . api . records . Token historyToken = BuilderUtils . newDelegationToken ( arg ) ;
org . apache . hadoop . yarn . api . records . Token token = recordFactory . newRecordInstance ( arg ) ;
Token token = getDelegationToken ( arg ) ;
return new TokenPBImpl ( arg ) ;
return new TokenPBImpl ( arg ) ;
return new TokenPBImpl ( arg ) ;
return new TokenPBImpl ( arg ) ;
return new TokenPBImpl ( arg ) ;
org . apache . hadoop . security . token . Token < ContainerTokenIdentifier > token = ProtoUtils . convertFromProtoFormat ( arg ) ;
Token containerToken = newToken ( arg ) ;
Token containerToken = BuilderUtils . newContainerToken ( arg ) ;
Token containerToken = request . getContainerToken ( arg ) ;
Token containerToken = BuilderUtils . newContainerToken ( arg ) ;
org . apache . hadoop . yarn . api . records . Token token = request . getContainerToken ( arg ) ;
Token containerToken = BuilderUtils . newContainerToken ( arg ) ;
Token containerToken = BuilderUtils . newContainerToken ( arg ) ;
Token containerToken = BuilderUtils . newContainerToken ( arg ) ;
Token containerToken = BuilderUtils . newContainerToken ( arg ) ;
Token containerToken = BuilderUtils . newContainerToken ( arg ) ;
Token containerToken1 = BuilderUtils . newContainerToken ( arg ) ;
Token containerToken2 = BuilderUtils . newContainerToken ( arg ) ;
Token containerToken = BuilderUtils . newContainerToken ( arg ) ;
Token containerToken = BuilderUtils . newContainerToken ( arg ) ;
Token containerToken = BuilderUtils . newContainerToken ( arg ) ;
Token containerToken = BuilderUtils . newContainerToken ( arg ) ;
Token containerToken = BuilderUtils . newContainerToken ( arg ) ;
Token containerToken = BuilderUtils . newContainerToken ( arg ) ;
Token containerToken = BuilderUtils . newContainerToken ( arg ) ;
org . apache . hadoop . yarn . api . records . Token protoToken = request . getDelegationToken ( arg ) ;
org . apache . hadoop . yarn . api . records . Token protoToken = request . getDelegationToken ( arg ) ;
org . apache . hadoop . yarn . api . records . Token clientToken = null ;
org . apache . hadoop . yarn . api . records . Token containerToken = containerTokenSecretManager . createContainerToken ( arg ) ;
Token containerToken = request . getContainerToken ( arg ) ;
Token containerToken = request . getContainerToken ( arg ) ;
org . apache . hadoop . yarn . api . records . Token dToken = BuilderUtils . newDelegationToken ( arg ) ;
org . apache . hadoop . yarn . api . records . Token token = getDelegationToken ( arg ) ;
org . apache . hadoop . yarn . api . records . Token delegationToken1 = response1 . getRMDelegationToken ( arg ) ;
org . apache . hadoop . yarn . api . records . Token delegationToken2 = response2 . getRMDelegationToken ( arg ) ;
org . apache . hadoop . yarn . api . records . Token clientToken = appReport . getClientToken ( arg ) ;
org . apache . hadoop . yarn . api . records . Token delegationToken = response . getRMDelegationToken ( arg ) ;
Token containerToken = newContainerToken ( arg ) ;
ApplicationId appId = ApplicationId . newInstance ( arg ) ;
ApplicationId applicationId = ApplicationId . newInstance ( arg ) ;
ApplicationId appId = ApplicationId . newInstance ( arg ) ;
ContainerTokenIdentifier containerTokenIdentifier = MRApp . newContainerTokenIdentifier ( arg ) ;
return MRApp . newContainerToken ( arg ) ;
org . apache . hadoop . yarn . api . records . Token dToken = org . apache . hadoop . yarn . api . records . Token . newInstance ( arg ) ;
org . apache . hadoop . yarn . api . records . Token dToken = org . apache . hadoop . yarn . api . records . Token . newInstance ( arg ) ;
org . apache . hadoop . yarn . api . records . Token mrDToken = org . apache . hadoop . yarn . api . records . Token . newInstance ( arg ) ;
org . apache . hadoop . yarn . api . records . Token historyToken = org . apache . hadoop . yarn . api . records . Token . newInstance ( arg ) ;
ApplicationId appId = ApplicationId . newInstance ( arg ) ;
Resource testCapability1 = Resource . newInstance ( arg ) ;
Resource testCapability2 = Resource . newInstance ( arg ) ;
Resource testCapability3 = Resource . newInstance ( arg ) ;
Resource testCapability4 = Resource . newInstance ( arg ) ;
Resource testCapability5 = Resource . newInstance ( arg ) ;
AllocateResponse response = AllocateResponse . newInstance ( arg ) ;
ApplicationId appId = ApplicationId . newInstance ( arg ) ;
return Container . newInstance ( arg ) ;
this . resource = Resource . newInstance ( arg ) ;
this . applicationAttemptId = ApplicationAttemptId . newInstance ( arg ) ;
return org . apache . hadoop . yarn . api . records . Token . newInstance ( arg ) ;
Token containerToken = TestRPC . newContainerToken ( arg ) ;
Token containerToken = newContainerToken ( arg ) ;
ApplicationId a5 = ApplicationId . newInstance ( arg ) ;
ContainerId c6 = newContainerId ( arg ) ;
throw new YarnRuntimeException ( arg ) ;
throw new YarnRuntimeException ( arg ) ;
throw new YarnRuntimeException ( arg ) ;
throw new YarnRuntimeException ( arg ) ;
throw new YarnRuntimeException ( arg ) ;
throw new YarnRuntimeException ( arg ) ;
throw new YarnRuntimeException ( arg ) ;
YarnException mockException = mock ( arg ) ;
return new YarnException ( arg ) ;
return new YarnException ( arg ) ;
throw new YarnException ( arg ) ;
throw new YarnException ( arg ) ;
throw new YarnException ( arg ) ;
throw new YarnException ( arg ) ;
final YarnRuntimeException yarnException = new YarnRuntimeException ( arg ) ;
Class < ? extends Throwable > exception = YarnException . class ;
Class < ? extends Throwable > exception = YarnException . class ;
throw new YarnRuntimeException ( arg ) ;
throw new YarnRuntimeException ( arg ) ;
throw new YarnRuntimeException ( arg ) ;
throw new YarnRuntimeException ( arg ) ;
throw new YarnRuntimeException ( arg ) ;
throw new YarnRuntimeException ( arg ) ;
throw new YarnRuntimeException ( arg ) ;
throw new YarnRuntimeException ( arg ) ;
throw new YarnRuntimeException ( arg ) ;
YarnRuntimeException e = new YarnRuntimeException ( arg ) ;
throw new YarnRuntimeException ( arg ) ;
throw new YarnRuntimeException ( arg ) ;
throw new YarnRuntimeException ( arg ) ;
throw new YarnRuntimeException ( arg ) ;
response . setResync ( arg ) ;
rebootResponse . setResync ( arg ) ;
response . setResync ( arg ) ;
return resync ;
return resync ;
return resync ;
( ( INodeDirectoryWithQuota ) inodes [ i ] . asDirectory ( arg ) ) . verifyQuota ( arg ) ;
final Snapshot snapshot = snapshotsByNames . get ( arg ) ;
rebootResponse . setAMCommand ( arg ) ;
nm = new TestNodeManager ( arg ) ;
service . unregisterServiceListener ( arg ) ;
service . registerServiceListener ( arg ) ;
service . registerServiceListener ( arg ) ;
svc . registerServiceListener ( arg ) ;
svc . registerServiceListener ( arg ) ;
svc . registerServiceListener ( arg ) ;
svc . unregisterServiceListener ( arg ) ;
svc . unregisterServiceListener ( arg ) ;
service . registerServiceListener ( arg ) ;
svc . registerServiceListener ( arg ) ;
service . registerServiceListener ( arg ) ;
Credentials appMasterCreds = appMaster . getCredentials ( arg ) ;
yarnRunner . addHistoryToken ( arg ) ;
yarnRunner . addHistoryToken ( arg ) ;
yarnRunner . addHistoryToken ( arg ) ;
yarnRunner . addHistoryToken ( arg ) ;
yarnRunner . addHistoryToken ( arg ) ;
MasterKey masterKey = regNMResponse . getContainerTokenMasterKey ( arg ) ;
resourceManager = new AMRMClientAsync ( arg ) ;
request . setFinalApplicationStatus ( arg ) ;
request . setFinalApplicationStatus ( arg ) ;
ShuffleSchedulerImpl < Text , Text > ss = mock ( arg ) ;
ShuffleSchedulerImpl < Text , Text > ss = mock ( arg ) ;
ShuffleSchedulerImpl < Text , Text > ss = mock ( arg ) ;
Iterable < NMTokenProto > iterable = getTokenProtoIterable ( arg ) ;
RMDelegationTokenSelector tokenSelector = new RMDelegationTokenSelector ( arg ) ;
ApplicationMasterProtocol realRM = amClient . rmClient ;
ApplicationMasterProtocol mockRM = mock ( arg ) ;
final ApplicationClientProtocol rmClient = getRmClient ( arg ) ;
final ApplicationClientProtocol rmClient = getRmClient ( arg ) ;
final ContainerManagementProtocol containerManager = nm . getContainerManager ( arg ) ;
ApplicationClientProtocol client = getClientRMService ( arg ) ;
ApplicationClientProtocol clientRMWithDT = null ;
ContainerManagementProtocol client = ( ContainerManagementProtocol ) yarnRPC . getProxy ( arg ) ;
yarnClient = YarnClient . createYarnClient ( arg ) ;
AMRMClient < ContainerRequest > amClient = null ;
amClient = AMRMClient . < ContainerRequest > createAMRMClient ( arg ) ;
amClient = ( AMRMClientImpl < StoredContainerRequest > ) AMRMClient . < StoredContainerRequest > createAMRMClient ( arg ) ;
AMRMClient < StoredContainerRequest > amClient = null ;
amClient = AMRMClient . < StoredContainerRequest > createAMRMClient ( arg ) ;
yarnClient = ( YarnClientImpl ) YarnClient . createYarnClient ( arg ) ;
rmClient = ( AMRMClientImpl < ContainerRequest > ) AMRMClient . < ContainerRequest > createAMRMClient ( arg ) ;
nmClient = ( NMClientImpl ) NMClient . createNMClient ( arg ) ;
Token < AMRMTokenIdentifier > appToken = appAttempt . getAMRMToken ( arg ) ;
AMRMTokenSecretManager appTokenMgr = new AMRMTokenSecretManager ( arg ) ;
report . setClientToAMToken ( arg ) ;
setupTokens ( arg ) ;
org . apache . hadoop . yarn . api . records . Token clientToAMToken = null ;
appAttempt . clientToAMToken = new Token < ClientToAMTokenIdentifier > ( arg ) ;
ClientToAMTokenSecretManagerInRM clientToAMTokenMgr = new ClientToAMTokenSecretManagerInRM ( arg ) ;
org . apache . hadoop . yarn . api . records . QueueInfo queueInfo = client . getQueueInfo ( arg ) ;
assertEquals ( arg ) ;
assertEquals ( arg ) ;
FileUtil . chmod ( arg ) ;
assertEquals ( arg ) ;
assertEquals ( arg ) ;
FileUtil . chmod ( arg ) ;
Token < ClientToAMTokenIdentifier > token = ConverterUtils . convertFromYarn ( arg ) ;
return ConverterUtils . convertFromYarn ( arg ) ;
org . apache . hadoop . security . token . Token < ContainerTokenIdentifier > token = ConverterUtils . convertFromYarn ( arg ) ;
Token < ContainerTokenIdentifier > token = ConverterUtils . convertFromYarn ( arg ) ;
Token < RMDelegationTokenIdentifier > token1 = ConverterUtils . convertFromYarn ( arg ) ;
Token < RMDelegationTokenIdentifier > token2 = ConverterUtils . convertFromYarn ( arg ) ;
Token < ClientToAMTokenIdentifier > token = ConverterUtils . convertFromYarn ( arg ) ;
Token < RMDelegationTokenIdentifier > token1 = ConverterUtils . convertFromYarn ( arg ) ;
ByteBuffer portInfo = response . getAllServicesMetaData ( arg ) . get ( arg ) ;
startResp . setAllServicesMetaData ( arg ) ;
startResp . setAllServicesMetaData ( arg ) ;
startResp . setAllServicesMetaData ( arg ) ;
startResp . setAllServicesMetaData ( arg ) ;
shuffleHandler . initializeApplication ( arg ) ;
response . setAllServicesMetaData ( arg ) ;
return startResponse . getAllServicesMetaData ( arg ) ;
asyncClient . getAvailableResources ( arg ) ;
return ns ;
return us ;
return TimeUnit . HOURS ;
return TimeUnit . DAYS ;
return TimeUnit . NANOSECONDS ;
return TimeUnit . MILLISECONDS ;
return TimeUnit . SECONDS ;
ContainerManagementProtocolProxyData proxy = null ;
ContainerManagementProtocolProxyData proxy = null ;
nmClientAsync = new NMClientAsyncImpl ( arg ) ;
ContainerManagementProtocolProxyData proxy = null ;
keyId = in . readInt ( arg ) ;
int keyId = identifier . getKeyId ( arg ) ;
nm . getContainerManager ( arg ) . startContainer ( arg ) ;
fs . delete ( arg ) ;
fs . rename ( arg ) ;
final AbstractINodeDiff < N , A , D > previous = diffs . get ( arg ) ;
final AbstractINodeDiff < N , A , D > last = getLast ( arg ) ;
FSImageSerialization . writeINodeDirectoryAttributes ( arg ) ;
INodeDirectoryAttributes dirCopy = null ;
INodeDirectoryAttributes snapshotINode = loadSnapshotINodeInDirectoryDiff ( arg ) ;
final INodeFileAttributes snapshotINode = in . readBoolean ( arg ) ? loader . loadINodeFileAttributes ( arg ) : null ;
return in . readBoolean ( arg ) ? loader . loadINodeDirectoryAttributes ( arg ) : null ;
NMTokenCache . setNMToken ( arg ) ;
NMTokenCache . setNMToken ( arg ) ;
NMTokenCache . setNMToken ( arg ) ;
HdfsFileStatusProto . Builder builder = HdfsFileStatusProto . newBuilder ( arg ) . setLength ( arg ) . setFileType ( arg ) . setBlockReplication ( arg ) . setBlocksize ( arg ) . setModificationTime ( arg ) . setAccessTime ( arg ) . setPermission ( arg ) . setOwner ( arg ) . setGroup ( arg ) . setFileId ( arg ) . setChildrenNum ( arg ) . setPath ( arg ) ;
Resource desiredFairShare = Resources . min ( arg ) ;
ComputeFairShares . computeShares ( arg ) ;
tis = new TarArchiveInputStream ( arg ) ;
p = qualifySymlinkTarget ( arg ) ;
fs . createSymlink ( arg ) ;
return fs . getFileLinkStatus ( arg ) ;
return fs . getLinkTarget ( arg ) ;
final int EXPECTED_TXNS_FIRST_SEG = 13 ;
final Type messageType = Type . fromValue ( arg ) ;
RpcMessage . Type invalidMessageType = RpcMessage . Type . RPC_REPLY ;
final MNTPROC mntproc = MNTPROC . fromValue ( arg ) ;
final NFSPROC3nfsproc3 = NFSPROC3 . fromValue ( arg ) ;
dataState = DataState . DUMPED ;
lb = appendFileInternal ( arg ) ;
Set < String > dedupedRacks = new HashSet < String > ( arg ) ;
rmClient = ClientRMProxy . createRMProxy ( arg ) ;
throw new java . net . ConnectException ( arg ) ;
AMRMClientImpl < ContainerRequest > amClient = null ;
amClient = ( AMRMClientImpl < ContainerRequest > ) AMRMClient . < ContainerRequest > createAMRMClient ( arg ) ;
List < ? extends Collection < ContainerRequest >> matches = amClient . getMatchingRequests ( arg ) ;
ContainerRequest storedRequest = matches . get ( arg ) . iterator ( arg ) . next ( arg ) ;
int iterationsLeft = 3 ;
AMRMClient < ContainerRequest > amClient = null ;
amClient = AMRMClient . < ContainerRequest > createAMRMClient ( arg ) ;
ContainerRequest testRequest = testSet . iterator ( arg ) . next ( arg ) ;
AMRMClientImpl < ContainerRequest > amClient = null ;
amClient = new AMRMClientImpl < ContainerRequest > ( arg ) ;
ContainerRequest storedContainer1 = new ContainerRequest ( arg ) ;
int iterationsLeft = 3 ;
iterationsLeft = 3 ;
Path nodeRemovePath = getAppDir ( arg ) ;
return callIdCounter . getAndIncrement ( arg ) & 0x7FFFFFFF ;
ContainerLaunchContext amContainer = BuilderUtils . newContainerLaunchContext ( arg ) ;
appContext . setResource ( arg ) ;
final RegisterApplicationMasterRequest req = Records . newRecord ( arg ) ;
containerTokens = request . getContainerLaunchContext ( arg ) . getTokens ( arg ) ;
AllocateResponse response1 = allocate ( arg ) ;
response1 = allocate ( arg ) ;
response1 = allocate ( arg ) ;
response1 = allocate ( arg ) ;
AllocateResponse response2 = allocate ( arg ) ;
response1 = allocate ( arg ) ;
response2 = allocate ( arg ) ;
response2 = allocate ( arg ) ;
AllocateResponse response = allocate ( arg ) ;
response = allocate ( arg ) ;
response = allocate ( arg ) ;
response = allocate ( arg ) ;
Client . setCallIdAndRetryCount ( arg ) ;
FSPermissionChecker checker = getPermissionChecker ( arg ) ;
nm . getContainerManager ( arg ) . startContainers ( arg ) ;
getContainerManager ( arg ) . startContainers ( arg ) ;
containerManager . startContainers ( arg ) ;
callbackHandler . asynClient = asyncClient ;
final int sizeLimit = ran . nextInt ( arg ) + 1 ;
String snapshotPath = null ;
status = startFileInt ( arg ) ;
return ms ;
return d ;
return TimeUnit . SECONDS ;
return TimeUnit . MICROSECONDS ;
return TimeUnit . MILLISECONDS ;
return TimeUnit . HOURS ;
return TimeUnit . MINUTES ;
return TimeUnit . NANOSECONDS ;
return TimeUnit . DAYS ;
checkPermission ( arg ) ;
AuthMethod authMethod = AuthMethod . SIMPLE ;
String expectedMessage =  ;
Token < AMRMTokenIdentifier > amrmToken = getAMRMToken ( arg ) ;
throw new IOException ( arg ) ;
throw new AssertionError ( arg ) ;
return false ;
assertEquals ( arg ) ;
RMServerUtils . validateResourceRequests ( arg ) ;
RMServerUtils . validateBlacklistRequest ( arg ) ;
final int childrenNum = ( childrenNumLong == null ) ? null : childrenNumLong . intValue ( arg ) ;
HashMap < String , Set < OneBlockInfo >> nodeToBlocks = new HashMap < String , Set < OneBlockInfo >> ( arg ) ;
HashMap < String , Set < OneBlockInfo >> nodeToBlocks = new HashMap < String , Set < OneBlockInfo >> ( arg ) ;
final Procedure portmapProc = Procedure . fromValue ( arg ) ;
return ns ;
return s ;
return TimeUnit . MICROSECONDS ;
return TimeUnit . HOURS ;
return TimeUnit . MINUTES ;
return TimeUnit . SECONDS ;
return TimeUnit . NANOSECONDS ;
return TimeUnit . MILLISECONDS ;
String target = FileUtil . readLink ( arg ) ;
String target = FileUtil . readLink ( arg ) ;
authMethod = AuthMethod . SIMPLE ;
processOneRpc ( arg ) ;
return serverPrincipal ;
final UserGroupInformation serverUgi = ( serverAuth == KERBEROS ) ? UserGroupInformation . createRemoteUser ( arg ) : UserGroupInformation . createRemoteUser ( arg ) ;
long totalMBExpect = metrics . getReservedMB ( arg ) + metrics . getAvailableMB ( arg ) + metrics . getAllocatedMB ( arg ) ;
long totalMBExpect = metrics . getAvailableMB ( arg ) + metrics . getAllocatedMB ( arg ) ;
command = new ArrayList < String > ( arg ) ;
boolean waitTimeValid = ( duration >= connectionWaitMs ) && ( duration < ( connectionWaitMs + delta ) ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
return TextFormat . shortDebugString ( arg ) ;
String authority = path . toUri ( arg ) . getAuthority ( arg ) ;
authority = fc . getDefaultFileSystem ( arg ) . getUri ( arg ) . getAuthority ( arg ) ;
String scheme = path . toUri ( arg ) . getScheme ( arg ) ;
scheme = fc . getDefaultFileSystem ( arg ) . getUri ( arg ) . getScheme ( arg ) ;
f . seralize ( arg ) ;
fos . hsync ( arg ) ;
fos . hsync ( arg ) ;
Keytab keytab = new Keytab ( arg ) ;
loginContext . logout ( arg ) ;
loginContext . logout ( arg ) ;
return ms ;
return m ;
return TimeUnit . NANOSECONDS ;
return TimeUnit . MICROSECONDS ;
return TimeUnit . DAYS ;
return TimeUnit . HOURS ;
return TimeUnit . MILLISECONDS ;
return TimeUnit . MINUTES ;
return TimeUnit . SECONDS ;
return m ;
return s ;
return TimeUnit . DAYS ;
return TimeUnit . MILLISECONDS ;
return TimeUnit . MICROSECONDS ;
return TimeUnit . SECONDS ;
return TimeUnit . NANOSECONDS ;
return TimeUnit . HOURS ;
int ret = c1 . getContainer ( arg ) . getPriority ( arg ) . compareTo ( arg ) ;
store . setRMDispatcher ( arg ) ;
namesystem . checkOperation ( arg ) ;
nodesReportStr = baos . toString ( arg ) ;
reports = client . getApplications ( arg ) ;
EnumSet < YarnApplicationState > applicationStates = request . getApplicationStates ( arg ) ;
nextOffset = flushedOffset ;
Credentials credentials = attemptState . getAppAttemptCredentials ( arg ) ;
Credentials credentials = getCredentialsFromAppAttempt ( arg ) ;
Credentials credentials = getCredentialsFromAppAttempt ( arg ) ;
appAttempt . removeCredentials ( arg ) ;
appAttempt . removeCredentials ( arg ) ;
Token < AMRMTokenIdentifier > appAttemptToken1 = generateAMRMToken ( arg ) ;
Token < AMRMTokenIdentifier > appAttemptToken2 = generateAMRMToken ( arg ) ;
primary . getExpectedStorageLocation ( arg ) . getDatanodeDescriptor ( arg ) . addBlockToBeRecovered ( arg ) ;
int datanodeNum = blkUC . getExpectedStorageLocations ( arg ) . length ;
datanodeNum = blkUC . getExpectedStorageLocations ( arg ) . length ;
return new ServerSidePathCacheEntriesIterator ( arg ) ;
prevKey = elementToPrevKey ( arg ) ;
RemoteIterator < CachePool > iter = server . listCachePools ( arg ) ;
CachePool pool = iter . next ( arg ) ;
builder . addEntries ( arg ) ;
return response . getEntriesCount ( arg ) ;
return PBHelper . convert ( arg ) ;
ListPathCacheEntriesRequestProto req = ListPathCacheEntriesRequestProto . newBuilder ( arg ) . setPrevEntry ( arg ) . setPool ( arg ) . setMaxReplies ( arg ) . build ( arg ) ;
return PBHelper . convert ( arg ) ;
return new InvalidPoolError ( arg ) ;
CacheEntryWithPayload cacheEntry = RetryCache . waitForCompletion ( arg ) ;
CachePool pool = null ;
return namesystem . addCachePool ( arg ) ;
conn = ( HttpURLConnection ) connectionFactory . openConnection ( arg ) ;
conn = ( HttpURLConnection ) connectionFactory . openConnection ( arg ) ;
conn = ( HttpURLConnection ) connectionFactory . openConnection ( arg ) ;
fs . connectionFactory = URLConnectionFactory . DEFAULT_CONNECTION_FACTORY ;
fs . connectionFactory = connectionFactory ;
List < INode > removedINodes = new ChunkedArrayList < INode > ( arg ) ;
List < INode > removedINodes = new ChunkedArrayList < INode > ( arg ) ;
return numBlocks ;
ContainerStatus status = SchedulerUtils . createPreemptedContainerStatus ( arg ) ;
Verifier verifier = Verifier . readFlavorAndVerifier ( arg ) ;
return size != 0 ? this . readFixedOpaque ( arg ) : new byte [ 0 ] ;
Verifier verifier = new VerifierNone ( arg ) ;
Credentials credentials = rpcCall . getCredential ( arg ) ;
clientService . init ( arg ) ;
Iterator < Entry < PathBasedCacheDirective , PathBasedCacheEntry >> iter = entriesByDirective . entrySet ( arg ) . iterator ( arg ) ;
Entry < PathBasedCacheDirective , PathBasedCacheEntry > entry = iter . next ( arg ) ;
PathBasedCacheEntry existing = entriesById . get ( arg ) ;
out . writeVariableOpaque ( arg ) ;
NativeIO . getMemlockLimit ( arg ) ;
long ulimit = NativeIO . getMemlockLimit ( arg ) ;
final long memlockLimit = NativeIO . getMemlockLimit ( arg ) ;
return activeApplications ;
return state == State . READING ? buf . limit ( arg ) : buf . position ( arg ) ;
writeVariableOpaque ( arg ) ;
RpcAcceptedReply . getAcceptInstance ( arg ) . write ( arg ) ;
RpcAcceptedReply . getAcceptInstance ( arg ) . write ( arg ) ;
RpcAcceptedReply . getAcceptInstance ( arg ) . write ( arg ) ;
return credentials ;
RpcAcceptedReply . getAcceptInstance ( arg ) . write ( arg ) ;
RpcAcceptedReply . getAcceptInstance ( arg ) . write ( arg ) ;
RpcAcceptedReply . getAcceptInstance ( arg ) . write ( arg ) ;
RpcAcceptedReply . getAcceptInstance ( arg ) . write ( arg ) ;
RpcAcceptedReply . getInstance ( arg ) . write ( arg ) ;
RpcCall . getInstance ( arg ) . write ( arg ) ;
RpcAcceptedReply . getInstance ( arg ) . write ( arg ) ;
return RpcAcceptedReply . getAcceptInstance ( arg ) . write ( arg ) ;
RpcAcceptedReply . getAcceptInstance ( arg ) . write ( arg ) ;
return RpcAcceptedReply . getAcceptInstance ( arg ) . write ( arg ) ;
RpcAcceptedReply . getInstance ( arg ) . write ( arg ) ;
out = response . writeHeaderAndResponse ( arg ) ;
return new NFS3Response ( arg ) ;
RpcCall . getInstance ( arg ) . write ( arg ) ;
final DatanodeStorageInfo [ ] targets = blockplacement . chooseTarget ( arg ) ;
LocatedBlock lBlk = new LocatedBlock ( arg ) ;
return createDatanodeStorageInfo ( arg ) ;
List < DatanodeStorageInfo > liveNodes = new LinkedList < DatanodeStorageInfo > ( arg ) ;
List < Fallible < PathBasedCacheDescriptor >> output = server . addPathBasedCacheDirectives ( arg ) ;
ListPathBasedCacheDescriptorsResponseProto response ;
ListPathBasedCacheDescriptorsRequestProto . Builder builder = ListPathBasedCacheDescriptorsRequestProto . newBuilder ( arg ) . setPrevId ( arg ) ;
ArrayList < Fallible < PathBasedCacheDescriptor >> results = new ArrayList < Fallible < PathBasedCacheDescriptor >> ( arg ) ;
return new Fallible < PathBasedCacheDescriptor > ( arg ) ;
return new Fallible < PathBasedCacheDescriptor > ( arg ) ;
return new Fallible < PathBasedCacheDescriptor > ( arg ) ;
PathBasedCacheEntry existing = findEntry ( arg ) ;
return new Fallible < PathBasedCacheDescriptor > ( arg ) ;
return new Fallible < PathBasedCacheDescriptor > ( arg ) ;
return new Fallible < PathBasedCacheDescriptor > ( arg ) ;
ArrayList < Fallible < PathBasedCacheDescriptor >> results = new ArrayList < Fallible < PathBasedCacheDescriptor >> ( arg ) ;
Iterator < Entry < Long , PathBasedCacheEntry >> iter = entriesById . entrySet ( arg ) . iterator ( arg ) ;
List < Fallible < PathBasedCacheDescriptor >> results = null ;
return namesystem . listPathBasedCacheDescriptors ( arg ) ;
List < Fallible < PathBasedCacheDescriptor >> results = dfs . addPathBasedCacheDirective ( arg ) ;
PathBasedCacheDescriptor entry = results . get ( arg ) . get ( arg ) ;
RemoteIterator < PathBasedCacheDescriptor > iter = dfs . listPathBasedCacheDescriptors ( arg ) ;
List < Fallible < Long >> results = dfs . removePathBasedCacheDescriptors ( arg ) ;
List < Fallible < PathBasedCacheDescriptor >> fallibles = nnRpc . addPathBasedCacheDirectives ( arg ) ;
RemoteIterator < PathBasedCacheDescriptor > entries = nnRpc . listPathBasedCacheDescriptors ( arg ) ;
PathBasedCacheDescriptor entry = entries . next ( arg ) ;
List < Fallible < Long >> fallibles = nnRpc . removePathBasedCacheDescriptors ( arg ) ;
List < Fallible < PathBasedCacheDescriptor >> addResults2 = proto . addPathBasedCacheDirectives ( arg ) ;
RemoteIterator < PathBasedCacheDescriptor > iter = proto . listPathBasedCacheDescriptors ( arg ) ;
iter = proto . listPathBasedCacheDescriptors ( arg ) ;
iter = proto . listPathBasedCacheDescriptors ( arg ) ;
iter = proto . listPathBasedCacheDescriptors ( arg ) ;
List < Fallible < Long >> removeResults1 = proto . removePathBasedCacheDescriptors ( arg ) ;
iter = proto . listPathBasedCacheDescriptors ( arg ) ;
List < String > existingStorageIDsList = req . getExistingStorageUuidsList ( arg ) ;
GetAdditionalDatanodeRequestProto req = GetAdditionalDatanodeRequestProto . newBuilder ( arg ) . setSrc ( arg ) . setBlk ( arg ) . addAllExistings ( arg ) . addAllExistingStorageUuids ( arg ) . addAllExcludes ( arg ) . setNumAdditionalNodes ( arg ) . setClientName ( arg ) . build ( arg ) ;
builder . addAllTargets ( arg ) . addAllTargetStorageUuids ( arg ) ;
List < String > storageIDs = targetStorageUuidsList . get ( arg ) . getStorageUuidsList ( arg ) ;
return DatanodeStorageProto . newBuilder ( arg ) . setState ( arg ) . setStorageType ( arg ) . setStorageUuid ( arg ) . build ( arg ) ;
return dfs . listCachePools ( arg ) ;
return dfs . listPathBasedCacheDescriptors ( arg ) ;
throw new InvalidPoolNameError ( arg ) ;
throw new PoolWritePermissionDeniedError ( arg ) ;
throw ioe ;
return existing . getDescriptor ( arg ) ;
throw new UnexpectedAddPathBasedCacheDirectiveException ( arg ) ;
throw ioe ;
return entry . getDescriptor ( arg ) ;
throw new InvalidIdException ( arg ) ;
throw new NoSuchIdException ( arg ) ;
throw new UnexpectedRemovePathBasedCacheDescriptorException ( arg ) ;
throw new RemovePermissionDeniedException ( arg ) ;
throw new UnexpectedRemovePathBasedCacheDescriptorException ( arg ) ;
throw e ;
commitOffset = nextOffset . get ( arg ) ;
return new WRITE3Response ( arg ) ;
return new WRITE3Response ( arg ) ;
long newValue = nonSequentialWriteInMemory . addAndGet ( arg ) ;
String RMWebAppURL = WebAppUtils . getResolvedRMWebAppURLWithScheme ( arg ) ;
appAttempt . clientTokenMasterKey = appAttempt . rmContext . getClientToAMTokenSecretManager ( arg ) . createMasterKey ( arg ) ;
registerApplication ( arg ) ;
SecretKey clientTokenKey1 = clientToAMTokenMgr . createMasterKey ( arg ) ;
SecretKey clientTokenKey2 = clientToAMTokenMgr . createMasterKey ( arg ) ;
amRMClient . addContainerRequest ( arg ) ;
amRMClient . stop ( arg ) ;
amRMClient . unregisterApplicationMaster ( arg ) ;
amRMClient . stop ( arg ) ;
RegisterApplicationMasterResponse response = amRMClient . registerApplicationMaster ( arg ) ;
amRMClient . addContainerRequest ( arg ) ;
return DatanodeIDProto . newBuilder ( arg ) . setIpAddr ( arg ) . setHostName ( arg ) . setXferPort ( arg ) . setDatanodeUuid ( arg ) . setInfoPort ( arg ) . setIpcPort ( arg ) . build ( arg ) ;
String secondNode = cluster . getDataNodes ( arg ) . get ( arg ) . getDatanodeId ( arg ) . getDatanodeUuid ( arg ) ;
return ( arg ) jsonMapper . readValue ( arg ) ;
return ( arg ) jsonMapper . readValue ( arg ) ;
int requestSize = xdrOut . size ( arg ) - headerSize ;
RpcResponse response = mock ( arg ) ;
RpcResponse response = mock ( arg ) ;
MRWebAppUtil . setJHSWebappURLWithoutScheme ( arg ) ;
MRWebAppUtil . setJHSWebappURLWithoutScheme ( arg ) ;
Resource available = Resources . subtract ( arg ) ;
containerManager . cleanUpApplications ( arg ) ;
entriesByPath . remove ( arg ) ;
return -addDirective ;
return -listDirectives ;
return -removeDirective ;
lines [ i ] = StringUtils . rightPad ( arg ) ;
applicationMaster . nmClientAsync . getContainerStatusAsync ( arg ) ;
cleanUpApplicationsOnNMShutDown ( arg ) ;
HttpConfig . setPolicy ( arg ) ;
HttpConfig . setPolicy ( arg ) ;
pool . getInfo ( arg ) . writeTo ( arg ) ;
this . info = CachePoolInfo . readXmlFrom ( arg ) ;
info = CachePoolInfo . readFrom ( arg ) ;
info . writeXmlTo ( arg ) ;
info . writeTo ( arg ) ;
httpsAddress = NetUtils . createSocketAddr ( arg ) ;
queueElements . add ( arg ) ;
Allocation allocation = resourceManager . getResourceScheduler ( arg ) . allocate ( arg ) ;
PathBasedCacheDirective directive = new PathBasedCacheDirective . Builder ( arg ) . setPath ( arg ) . setPool ( arg ) . build ( arg ) ;
PathBasedCacheDirective directive = new PathBasedCacheDirective . Builder ( arg ) . setPath ( arg ) . setPool ( arg ) . build ( arg ) ;
iter = dfs . listPathBasedCacheDescriptors ( arg ) ;
int numExpectedElements = 11 ;
numExpectedElements = 21 ;
PathBasedCacheDirective directive = new PathBasedCacheDirective . Builder ( arg ) . setPath ( arg ) . setReplication ( arg ) . setPool ( arg ) . build ( arg ) ;
return new EqualsBuilder ( arg ) . append ( arg ) . append ( arg ) . append ( arg ) . append ( arg ) . isEquals ( arg ) ;
return new HashCodeBuilder ( arg ) . append ( arg ) . append ( arg ) . append ( arg ) . append ( arg ) . hashCode ( arg ) ;
return new EqualsBuilder ( arg ) . append ( arg ) . append ( arg ) . append ( arg ) . isEquals ( arg ) ;
return new HashCodeBuilder ( arg ) . append ( arg ) . append ( arg ) . append ( arg ) . hashCode ( arg ) ;
AddPathBasedCacheDirectiveOp op = AddPathBasedCacheDirectiveOp . getInstance ( arg ) . setPath ( arg ) . setReplication ( arg ) . setPool ( arg ) ;
PathBasedCacheDirective directive = new PathBasedCacheDirective . Builder ( arg ) . setPath ( arg ) . setReplication ( arg ) . setPool ( arg ) . build ( arg ) ;
HdfsFileStatus dirStatus = null ;
dlisting = listPaths ( arg ) ;
dlisting = listPaths ( arg ) ;
int start = startPositionWithoutWindowsDrive ( arg ) ;
int start = startPositionWithoutWindowsDrive ( arg ) ;
blockLog . info ( arg ) ;
cacheManager . deactivate ( arg ) ;
namesystem . getCacheManager ( arg ) . processCacheReport ( arg ) ;
IOException e = lastException . get ( arg ) ;
setScheduledSize ( arg ) ;
final FSPermissionChecker pc = getPermissionChecker ( arg ) ;
httpsAddress = NetUtils . createSocketAddr ( arg ) ;
FileStatus linkStatus = null ;
long [ ] blocks = new long [ locs . length ] ;
blocks [ i ] = locs [ i ] . getLocatedBlock ( arg ) . getBlock ( arg ) . getBlockId ( arg ) ;
return new BlockIdCommand ( arg ) ;
String file = test_compress.txt ;
String text = ( ( Text ) field . getFirstChild ( arg ) ) . getData ( arg ) . trim ( arg ) ;
String text = ( ( Text ) field . getFirstChild ( arg ) ) . getData ( arg ) . trim ( arg ) ;
String text = ( ( Text ) field . getFirstChild ( arg ) ) . getData ( arg ) ;
String text = ( ( Text ) field . getFirstChild ( arg ) ) . getData ( arg ) ;
List < Long > blockIds = dn . getFSDataset ( arg ) . getCacheReport ( arg ) ;
long cacheUsed = fsd . getDnCacheUsed ( arg ) ;
cacheUsed = fsd . getDnCacheUsed ( arg ) ;
return minRacks - racks . size ( arg ) ;
return conf . getStringCollection ( arg ) ;
HAUtil . verifyAndSetConfiguration ( arg ) ;
DFSClient dfsClient = clientCache . getDfsClient ( arg ) ;
DFSClient dfsClient = clientCache . getDfsClient ( arg ) ;
DFSClient dfsClient = clientCache . getDfsClient ( arg ) ;
DFSClient dfsClient = clientCache . getDfsClient ( arg ) ;
DFSClient dfsClient = clientCache . getDfsClient ( arg ) ;
DFSClient dfsClient = clientCache . getDfsClient ( arg ) ;
DFSClient dfsClient = clientCache . getDfsClient ( arg ) ;
DFSClient dfsClient = clientCache . getDfsClient ( arg ) ;
DFSClient dfsClient = clientCache . getDfsClient ( arg ) ;
DFSClient dfsClient = clientCache . getDfsClient ( arg ) ;
DFSClient dfsClient = clientCache . getDfsClient ( arg ) ;
DFSClient dfsClient = clientCache . getDfsClient ( arg ) ;
DFSClient dfsClient = clientCache . getDfsClient ( arg ) ;
DFSClient dfsClient = clientCache . getDfsClient ( arg ) ;
DFSClient dfsClient = clientCache . getDfsClient ( arg ) ;
DFSClient dfsClient = clientCache . getDfsClient ( arg ) ;
DFSClient dfsClient = clientCache . getDfsClient ( arg ) ;
DFSClient dfsClient = clientCache . getDfsClient ( arg ) ;
DFSClient dfsClient = clientCache . getDfsClient ( arg ) ;
cache . getDfsClient ( arg ) ;
doReturn ( arg ) . when ( arg ) . getHistoryDirsForCleaning ( arg ) ;
haService = createRMHAProtocolService ( arg ) ;
return NM_TOKEN_CACHE . getToken ( arg ) ;
NM_TOKEN_CACHE . setToken ( arg ) ;
getNMTokenCache ( arg ) . setToken ( arg ) ;
rmClient . getNMTokenCache ( arg ) . setToken ( arg ) ;
app . rmContext . getStateStore ( arg ) . storeNewApplication ( arg ) ;
return ( arg ) ? this . originalTrackingUrl : this . proxiedTrackingUrl ;
store . storeNewApplicationAttempt ( arg ) ;
event = new RMAppNewSavedEvent ( arg ) ;
event = new RMAppNewSavedEvent ( arg ) ;
RMAppEvent event = new RMAppNewSavedEvent ( arg ) ;
return ns ;
return TimeUnit . MILLISECONDS ;
return TimeUnit . NANOSECONDS ;
return TimeUnit . MINUTES ;
return TimeUnit . DAYS ;
return TimeUnit . MICROSECONDS ;
return TimeUnit . SECONDS ;
return ! iterators . isEmpty ( arg ) && iterators . get ( arg ) . hasNext ( arg ) ;
return perNode . getResource ( arg ) ;
boolean badTarget = false ;
OpenFileCtx openFileCtx = fileContextCache . get ( arg ) ;
OpenFileCtx openFileCtx = fileContextCache . get ( arg ) ;
OpenFileCtx openFileCtx = fileContextCache . get ( arg ) ;
OpenFileCtx openFileCtx = fileContextCache . get ( arg ) ;
RpcProgramMountd mountd = ( RpcProgramMountd ) nfs3 . getMountd ( arg ) . getRpcProgram ( arg ) ;
ListPathBasedCacheDirectivesResponseProto response ;
return new EqualsBuilder ( arg ) . append ( arg ) . append ( arg ) . append ( arg ) . append ( arg ) . isEquals ( arg ) ;
return new HashCodeBuilder ( arg ) . append ( arg ) . append ( arg ) . append ( arg ) . append ( arg ) . hashCode ( arg ) ;
AddPathBasedCacheDirectiveOp op = AddPathBasedCacheDirectiveOp . getInstance ( arg ) . setDirective ( arg ) ;
return namesystem . listPathBasedCacheDirectives ( arg ) ;
RemoteIterator < PathBasedCacheDirective > iter = dfs . listPathBasedCacheDirectives ( arg ) ;
dfs . getClient ( arg ) . removePathBasedCacheDirective ( arg ) ;
RemoteIterator < PathBasedCacheDirective > iter = dfs . listPathBasedCacheDirectives ( arg ) ;
PathBasedCacheDirective directive = iter . next ( arg ) ;
dfs . removePathBasedCacheDirective ( arg ) ;
proto . removePathBasedCacheDirective ( arg ) ;
proto . removePathBasedCacheDirective ( arg ) ;
RemoteIterator < PathBasedCacheDirective > dit = dfs . listPathBasedCacheDirectives ( arg ) ;
dit = dfs . listPathBasedCacheDirectives ( arg ) ;
RemoteIterator < PathBasedCacheDirective > entries = nnRpc . listPathBasedCacheDirectives ( arg ) ;
dfs . removePathBasedCacheDirective ( arg ) ;
RemoteIterator < PathBasedCacheDirective > iter = dfs . listPathBasedCacheDirectives ( arg ) ;
result = client . addPathBasedCacheDirective ( arg ) ;
AtMostOnceOp op = new RemovePathBasedCacheDirectiveOp ( arg ) ;
return usedBytesCount . get ( arg ) ;
total = verifyExpectedCacheUsage ( arg ) ;
priorDiff = diffList . getDiff ( arg ) ;
throw new RetriableException ( arg ) ;
return BlockWithLocationsProto . newBuilder ( arg ) . setBlock ( arg ) . addAllDatanodeUuids ( arg ) . addAllStorageUuids ( arg ) . build ( arg ) ;
return new StorageReport [ ] { val } ;
long curDnCacheUsed = fsd . getCacheUsed ( arg ) ;
TableListing tableListing = new TableListing . Builder ( arg ) . addField ( arg ) . addField ( arg ) . addField ( arg ) . addField ( arg ) . build ( arg ) ;
NativeIO . POSIX . cacheManipulator . mlock ( arg ) ;
blockManager . getDatanodeManager ( arg ) . setShouldSendCachingCommands ( arg ) ;
blockManager . getDatanodeManager ( arg ) . setShouldSendCachingCommands ( arg ) ;
NativeIO . POSIX . cacheManipulator = prevCacheManipulator ;
isUber = uberEnabled && smallNumMapTasks && smallNumReduceTasks && smallInput && smallMemory && smallCpu && notChainJob ;
List < String > childNodes = getChildrenWithRetries ( arg ) ;
List < String > childNodes = getChildrenWithRetries ( arg ) ;
return connectionManager . toArray ( arg ) ;
Connection connection = server . getConnections ( arg ) [ 0 ] ;
tokenAspect . reset ( arg ) ;
WebHdfsFileSystem fs = spyWebhdfsInSecureSetup ( arg ) ;
return YarnConfiguration . RM_RPC_ADDRESS_CONF_KEYS . contains ( arg ) ? addSuffix ( arg ) : prefix ;
prevId = dfs . addPathBasedCacheDirective ( arg ) ;
journalNodeInfoBeanName = MBeans . register ( arg ) ;
NativeIO . POSIX . getCacheManipulator ( arg ) . posixFadviseIfPossible ( arg ) ;
NativeIO . POSIX . getCacheManipulator ( arg ) . posixFadviseIfPossible ( arg ) ;
NativeIO . POSIX . getCacheManipulator ( arg ) . posixFadviseIfPossible ( arg ) ;
NativeIO . POSIX . getCacheManipulator ( arg ) . posixFadviseIfPossible ( arg ) ;
NativeIO . POSIX . getCacheManipulator ( arg ) . posixFadviseIfPossible ( arg ) ;
long ulimit = NativeIO . POSIX . getCacheManipulator ( arg ) . getMemlockLimit ( arg ) ;
NativeIO . POSIX . getCacheManipulator ( arg ) . mlock ( arg ) ;
final long memlockLimit = NativeIO . POSIX . getCacheManipulator ( arg ) . getMemlockLimit ( arg ) ;
NativeIO . POSIX . setCacheManipulator ( arg ) ;
NativeIO . POSIX . setCacheManipulator ( arg ) ;
NativeIO . POSIX . setCacheManipulator ( arg ) ;
NativeIO . POSIX . getCacheManipulator ( arg ) . posixFadviseIfPossible ( arg ) ;
NativeIO . POSIX . getCacheManipulator ( arg ) . posixFadviseIfPossible ( arg ) ;
AllocateResponseLock lastResponse = responseMap . get ( arg ) ;
lock . setAllocateResponse ( arg ) ;
return new PathBasedCacheDirective . Builder ( arg ) . setId ( arg ) . setPath ( arg ) . setReplication ( arg ) . setPool ( arg ) . setBytesNeeded ( arg ) . setBytesCached ( arg ) . setFilesAffected ( arg ) . build ( arg ) ;
return kind . equals ( arg ) || kind . equals ( arg ) || kind . equals ( arg ) || kind . equals ( arg ) ;
this . nnAddrs = DFSUtil . resolveWebHdfsUri ( arg ) ;
Map < String , Map < String , InetSocketAddress >> map = DFSUtil . getHaNnWebHdfsAddresses ( arg ) ;
InetSocketAddress [ ] addrs = DFSUtil . resolveWebHdfsUri ( arg ) ;
return other != null && getQuotaCounts ( arg ) . equals ( arg ) && getPermissionLong ( arg ) == other . getPermissionLong ( arg ) ;
return new BatchedCachePoolInfo ( arg ) ;
rescanCacheDirectives ( arg ) ;
CacheDirective entry = entriesById . get ( arg ) ;
CacheDirective entry = new CacheDirective ( arg ) ;
List < CacheDirective > entries = entriesByPath . get ( arg ) ;
entries = new LinkedList < CacheDirective > ( arg ) ;
INodeFile cons = FSImageSerialization . readINodeUnderConstruction ( arg ) ;
final FileUnderConstructionFeature uc = file . getFileUnderConstructionFeature ( arg ) ;
boolean remove = iFile . removeLastBlock ( arg ) ;
iFile . setLastBlock ( arg ) ;
final INodeFile pendingFile = inodes [ inodes . length - 1 ] . asFile ( arg ) ;
final INodeFile pendingFile = inodes [ inodes . length - 1 ] . asFile ( arg ) ;
final BlockCollection mbc = mock ( arg ) ;
INodeFile fileNode = cluster . getNamesystem ( arg ) . getFSDirectory ( arg ) . getINode4Write ( arg ) . asFile ( arg ) ;
INodeFile fooNode = fooRef . asFile ( arg ) ;
node . setDatanodeUuidForTesting ( arg ) ;
node . setDatanodeUuidForTesting ( arg ) ;
final String storageID = DatanodeStorage . generateUuid ( arg ) ;
final URLConnectionFactory connectionFactory = URLConnectionFactory . DEFAULT_SYSTEM_CONNECTION_FACTORY ;
initTokenAspect ( arg ) ;
fs . connectionFactory = URLConnectionFactory . DEFAULT_SYSTEM_CONNECTION_FACTORY ;
final int portmapProc = rpcCall . getProcedure ( arg ) ;
@ SuppressWarnings ( arg ) Map < String , PortmapMapping > map = ( Map < String , PortmapMapping > ) Whitebox . getInternalState ( arg ) ;
q . verifyQuota ( arg ) ;
dir . getDirectoryWithQuotaFeature ( arg ) . setSpaceConsumed ( arg ) ;
fsDir . rootDir . getDirectoryWithQuotaFeature ( arg ) . setQuota ( arg ) ;
getDirectoryWithQuotaFeature ( arg ) . addSpaceConsumed2Cache ( arg ) ;
getDirectoryWithQuotaFeature ( arg ) . addSpaceConsumed2Cache ( arg ) ;
INodeDirectory dirNode = getDir ( arg ) ;
INodeDirectory dirNode = getDir ( arg ) ;
RemoteIterator < CachePoolEntry > iter = server . listCachePools ( arg ) ;
return new BatchedCachePoolEntries ( arg ) ;
return id == other . id ;
return cacheManager . getCacheCapacity ( arg ) ;
return cacheManager . getCacheUsed ( arg ) ;
nextDirectiveId = in . readLong ( arg ) ;
loadDirectives ( arg ) ;
saveDirectives ( arg ) ;
BatchedListEntries < CachePoolEntry > results ;
RemoteIterator < CachePoolEntry > iter = dfs . listCachePools ( arg ) ;
RemoteIterator < CachePoolEntry > pit = dfs . listCachePools ( arg ) ;
CachePoolInfo info = pit . next ( arg ) . getInfo ( arg ) ;
info = pit . next ( arg ) . getInfo ( arg ) ;
RemoteIterator < CachePoolEntry > iter = dfs . listCachePools ( arg ) ;
RemoteIterator < CachePoolEntry > iter = dfs . listCachePools ( arg ) ;
return localServerBuilder ( arg ) . setFindPort ( arg ) . build ( arg ) ;
return localServerBuilder ( arg ) . setFindPort ( arg ) . setConf ( arg ) . build ( arg ) ;
return localServerBuilder ( arg ) . setFindPort ( arg ) . setConf ( arg ) . setACL ( arg ) . build ( arg ) ;
return localServerBuilder ( arg ) . setFindPort ( arg ) . setConf ( arg ) . setPathSpec ( arg ) . build ( arg ) ;
return new HttpServer . Builder ( arg ) . setName ( arg ) . addEndpoint ( URI . create ( http:
HttpServer myServer = new HttpServer . Builder ( arg ) . setName ( arg ) . addEndpoint ( new URI ( http:
HttpServer myServer = new HttpServer . Builder ( arg ) . setName ( arg ) . addEndpoint ( new URI ( http:
HttpServer server = new HttpServer . Builder ( arg ) . setName ( arg ) . addEndpoint ( new URI ( http:
HttpServer . defineFilter ( arg ) ;
HttpServer server = new HttpServer . Builder ( arg ) . setName ( arg ) . addEndpoint ( URI . create ( http:
server = new HttpServer . Builder ( arg ) . setName ( arg ) . addEndpoint ( URI . create ( http:
this . port = this . webApp . httpServer ( arg ) . getConnectorAddress ( arg ) . getPort ( arg ) ;
proxyServer = new HttpServer . Builder ( arg ) . setName ( arg ) . addEndpoint ( URI . create ( http:
proxyServer = new HttpServer . Builder ( arg ) . setName ( arg ) . addEndpoint ( URI . create ( http:
int proxyPort = proxy . proxy . proxyServer . getConnectorAddress ( arg ) . getPort ( arg ) ;
return getFileReplication ( arg ) ;
this . collectBlocksAndClear ( arg ) ;
return new CacheDirectiveInfo . Builder ( arg ) . setId ( arg ) . setPath ( arg ) . setReplication ( arg ) . setPool ( arg ) . setExpiration ( arg ) . build ( arg ) ;
return new CacheDirectiveStats . Builder ( arg ) . setBytesNeeded ( arg ) . setBytesCached ( arg ) . setFilesAffected ( arg ) . setHasExpired ( arg ) . build ( arg ) ;
return new EqualsBuilder ( arg ) . append ( arg ) . append ( arg ) . append ( arg ) . append ( arg ) . append ( arg ) . isEquals ( arg ) ;
return new HashCodeBuilder ( arg ) . append ( arg ) . append ( arg ) . append ( arg ) . append ( arg ) . append ( arg ) . hashCode ( arg ) ;
directive = new CacheDirectiveInfo . Builder ( arg ) . setId ( arg ) . setPath ( arg ) . setReplication ( arg ) . setPool ( arg ) . setExpiration ( arg ) . build ( arg ) ;
byte flags = ( byte ) ( ( ( directive . getPath ( arg ) != null ) ? 0x1 : 0 ) | ( ( directive . getReplication ( arg ) != null ) ? 0x2 : 0 ) | ( ( directive . getPool ( arg ) != null ) ? 0x4 : 0 ) | ( ( directive . getExpiration ( arg ) != null ) ? 0x8 : 0 ) ) ;
CacheDirectiveInfo directive = builder . build ( arg ) ;
TableListing . Builder tableBuilder = new TableListing . Builder ( arg ) . addField ( arg ) . addField ( arg ) . addField ( arg ) . addField ( arg ) . addField ( arg ) ;
return checkAccess ( arg ) ;
adminService . transitionToStandby ( arg ) ;
rm . adminService . monitorHealth ( arg ) ;
rm . adminService . transitionToStandby ( arg ) ;
rm . adminService . transitionToActive ( arg ) ;
rm . adminService . transitionToActive ( arg ) ;
rm . adminService . transitionToStandby ( arg ) ;
rm . adminService . transitionToActive ( arg ) ;
rm1 . getRMContext ( arg ) . getRMAdminService ( arg ) . transitionToActive ( arg ) ;
rm2 . getRMContext ( arg ) . getRMAdminService ( arg ) . transitionToActive ( arg ) ;
Map < DatanodeStorage , BlockListAsLongs > perVolumeBlockLists = dn . getFSDataset ( arg ) . getBlockReports ( arg ) ;
Map < DatanodeStorage , BlockListAsLongs > blockReportMap = new HashMap < DatanodeStorage , BlockListAsLongs > ( arg ) ;
List < Map < DatanodeStorage , BlockListAsLongs >> blocks = cluster . getAllBlockReports ( arg ) ;
List < Map < DatanodeStorage , BlockListAsLongs >> blocksList = cluster . getAllBlockReports ( arg ) ;
Map < DatanodeStorage , BlockListAsLongs > perVolumeBlockLists = dn . getFSDataset ( arg ) . getBlockReports ( arg ) ;
Map < DatanodeStorage , BlockListAsLongs > perVolumeBlockLists = dn . getFSDataset ( arg ) . getBlockReports ( arg ) ;
builder . addEndpoint ( URI . create ( https:
this . infoServer = builder . build ( arg ) ;
return scheduler . getAllocationConfiguration ( arg ) . getMaxResources ( arg ) ;
int queueMaxApps = allocConf . getQueueMaxApps ( arg ) ;
FSQueue highestQueueWithAppsNowRunnable = ( queue . getNumRunnableApps ( arg ) == allocConf . getQueueMaxApps ( arg ) - 1 ) ? queue : null ;
scheduler . reinitialize ( arg ) ;
scheduler . getAllocationConfiguration ( arg ) . placementPolicy = new QueuePlacementPolicy ( arg ) ;
scheduler . getAllocationConfiguration ( arg ) . placementPolicy = new QueuePlacementPolicy ( arg ) ;
return new CacheDirectiveStats . Builder ( arg ) . setBytesNeeded ( arg ) . setBytesCached ( arg ) . setFilesNeeded ( arg ) . setFilesCached ( arg ) . setHasExpired ( arg ) . build ( arg ) ;
return bytesCached ;
directive . addFilesNeeded ( arg ) ;
return new CachePoolStats . Builder ( arg ) . setBytesNeeded ( arg ) . setBytesCached ( arg ) . setFilesNeeded ( arg ) . setFilesCached ( arg ) . build ( arg ) ;
tableBuilder . addField ( arg ) . addField ( arg ) . addField ( arg ) . addField ( arg ) ;
LinkedList < String > row = new LinkedList < String > ( arg ) ;
return fileDiffs == null ? file : new INodeFile ( arg ) ;
return fileDiffs == null ? file : new INodeFile ( arg ) ;
INodeFile sfoo = fsdir . getINode ( arg ) . asFile ( arg ) ;
INodeFile snode = fsdir . getINode ( arg ) . asFile ( arg ) ;
INodeFile bar1 = fsdir . getINode4Write ( arg ) . asFile ( arg ) ;
INodeFile bar = barWithCount . asFile ( arg ) ;
INodeFile bar1 = fsdir . getINode4Write ( arg ) . asFile ( arg ) ;
INodeFile bar = barWithCount . asFile ( arg ) ;
bar = barWithCount . asFile ( arg ) ;
INodeFile barNode = fsdir . getINode4Write ( arg ) . asFile ( arg ) ;
INodeFile metaChangeFile2SCopy = children . get ( arg ) . asFile ( arg ) ;
Iterable < ContainerProto > iterable = getContainerProtoIterable ( arg ) ;
return HAServiceState . ACTIVE == rmContext . getHAServiceState ( arg ) ;
rm . transitionToStandby ( arg ) ;
return Objects . equal ( arg ) && Objects . equal ( arg ) && stickyBit == other . stickyBit && Objects . equal ( arg ) ;
List < AclEntry > actual = Lists . newArrayList ( arg ) ;
throw ( arg ) getTrueCause ( arg ) ;
return YarnConfiguration . RM_SERVICES_ADDRESS_CONF_KEYS . contains ( arg ) ? addSuffix ( arg ) : prefix ;
verifyAndSetAllServiceAddresses ( arg ) ;
SchedulerEvent event1 = new AppAttemptAddedSchedulerEvent ( arg ) ;
scheduler . addApplicationAttempt ( arg ) ;
fs . addApplicationAttempt ( arg ) ;
AppAttemptRemovedSchedulerEvent appRemoveEvent = ( AppAttemptRemovedSchedulerEvent ) schedulerEvent ;
sf . getSnapshotDirectory ( arg ) ;
replaceSelf ( arg ) . getDirectoryWithSnapshotFeature ( arg ) . getDiffs ( arg ) . saveSelf2Snapshot ( arg ) ;
return sf . getDiffs ( arg ) . getSnapshotINode ( arg ) ;
DirectoryWithSnapshotFeature . destroyDstSubtree ( arg ) ;
INodeDirectory barNode = fsdir . getINode ( arg ) . asDirectory ( arg ) ;
INodeDirectory fooDir = fooWC . getReferredINode ( arg ) . asDirectory ( arg ) ;
INodeDirectory fooNode = wc . getReferredINode ( arg ) . asDirectory ( arg ) ;
INodeDirectory fooNode = wc . getReferredINode ( arg ) . asDirectory ( arg ) ;
INodeDirectory dir2Node = fsdir . getINode4Write ( arg ) . asDirectory ( arg ) ;
INodeDirectory dir1Node = fsdir . getINode4Write ( arg ) . asDirectory ( arg ) ;
INodeDirectory barNode = fsdir . getINode4Write ( arg ) . asDirectory ( arg ) ;
INodeDirectory dir2Node = fsdir . getINode4Write ( arg ) . asDirectory ( arg ) ;
INodeDirectory foo = fooWithCount . asDirectory ( arg ) ;
INodeDirectory foo = fooWithCount . asDirectory ( arg ) ;
foo = fooWithCount . asDirectory ( arg ) ;
List < DirectoryDiff > fooDiffs = fooNode . asDirectory ( arg ) . getDiffs ( arg ) . asList ( arg ) ;
fooDiffs = fooNode . asDirectory ( arg ) . getDiffs ( arg ) . asList ( arg ) ;
diffList = subdir2Node . asDirectory ( arg ) . getDiffs ( arg ) . asList ( arg ) ;
INodeDirectory fooNode = fsdir . getINode4Write ( arg ) . asDirectory ( arg ) ;
diffList = fsdir . getINode ( arg ) . asDirectory ( arg ) . getDiffs ( arg ) ;
ArrayList < StorageReceivedDeletedBlocks > reports = new ArrayList < StorageReceivedDeletedBlocks > ( arg ) ;
reports . add ( arg ) ;
long delta = ( startTimeMs + intervalMs ) - curTimeMs ;
return info . setOwnerName ( arg ) . setGroupName ( arg ) . setMode ( arg ) . setLimit ( arg ) ;
return new CachePoolStats . Builder ( arg ) . setBytesNeeded ( arg ) . setBytesCached ( arg ) . setBytesOverlimit ( arg ) . setFilesNeeded ( arg ) . setFilesCached ( arg ) . build ( arg ) ;
directive = FSImageSerialization . readCacheDirectiveInfo ( arg ) ;
this . info = FSImageSerialization . readCachePoolInfo ( arg ) ;
info = FSImageSerialization . readCachePoolInfo ( arg ) ;
FSImageSerialization . writeCachePoolInfo ( arg ) ;
this . info = FSImageSerialization . readCachePoolInfo ( arg ) ;
info = FSImageSerialization . readCachePoolInfo ( arg ) ;
FSImageSerialization . writeCachePoolInfo ( arg ) ;
builder . addField ( arg ) . addField ( arg ) . addField ( arg ) . addField ( arg ) . addField ( arg ) ;
CachePoolInfo info = new CachePoolInfo ( arg ) . setOwnerName ( arg ) . setGroupName ( arg ) . setMode ( arg ) . setLimit ( arg ) ;
info . setOwnerName ( arg ) . setGroupName ( arg ) . setMode ( arg ) . setLimit ( arg ) ;
return new BlockReaderLocal . Builder ( arg ) . setFilename ( arg ) . setBlock ( arg ) . setStartOffset ( arg ) . setStreams ( arg ) . setDatanodeID ( arg ) . setVerifyChecksum ( arg ) . setBlockMetadataHeader ( arg ) . setFileInputStreamCache ( arg ) . setCachingStrategy ( arg ) . build ( arg ) ;
this . cachingStrategy = new CachingStrategy . Builder ( arg ) . setDropBehind ( arg ) . build ( arg ) ;
this . cachingStrategy = new CachingStrategy . Builder ( arg ) . setReadahead ( arg ) . build ( arg ) ;
( ( SchedulerWrapper ) rm . getResourceScheduler ( arg ) ) . addAMRuntime ( arg ) ;
( ( SchedulerWrapper ) rm . getResourceScheduler ( arg ) ) . addTrackedApp ( arg ) ;
( ( SchedulerWrapper ) rm . getResourceScheduler ( arg ) ) . removeTrackedApp ( arg ) ;
return fqdn + : + d . getInfoPort ( arg ) ;
return fqdn + : + d . getInfoSecurePort ( arg ) ;
String appIdRemovePath = getNodePath ( arg ) ;
return saslFactory . createSaslServer ( arg ) ;
attemptsTableData . append ( arg ) . append ( arg ) . append ( arg ) . append ( arg ) . append ( arg ) . append ( arg ) . append ( arg ) . append ( arg ) . append ( arg ) . append ( arg ) . append ( arg ) . append ( arg ) . append ( arg ) . append ( arg ) . append ( arg ) . append ( arg ) . append ( arg ) . append ( arg ) . append ( arg ) . append ( arg ) . append ( arg ) ;
long ttl ;
ttl = Long . parseLong ( arg ) ;
return new EqualsBuilder ( arg ) . append ( arg ) . append ( arg ) . append ( arg ) . append ( arg ) . append ( arg ) . append ( arg ) . isEquals ( arg ) ;
return new HashCodeBuilder ( arg ) . append ( arg ) . append ( arg ) . append ( arg ) . append ( arg ) . append ( arg ) . append ( arg ) . hashCode ( arg ) ;
return info . setOwnerName ( arg ) . setGroupName ( arg ) . setMode ( arg ) . setLimit ( arg ) . setMaxRelativeExpiryMs ( arg ) ;
TableListing . Builder builder = new TableListing . Builder ( arg ) . addField ( arg ) . addField ( arg ) . addField ( arg ) . addField ( arg ) . addField ( arg ) . addField ( arg ) ;
maxFailoverAttempts = Integer . MAX_VALUE ;
maxFailoverAttempts = ( int ) ( rmConnectWaitMS
return this . rmContext . getAMRMTokenSecretManager ( arg ) ;
return this . rmContext . getNMTokenSecretManager ( arg ) ;
getRMDTSecretManager ( arg ) . recover ( arg ) ;
throwStandbyException ( arg ) ;
throwStandbyException ( arg ) ;
throwStandbyException ( arg ) ;
throwStandbyException ( arg ) ;
