if ( ! leakDetector . acquired ( arg ) ) LOG . info ( arg ) ;
if ( ! leakDetector . released ( arg ) ) LOG . info ( arg ) ;
timeoutTask . cancel ( arg ) ;
timeoutTask . cancel ( arg ) ;
return session . isBatching ( arg ) ;
session . setBatching ( arg ) ;
return jettyRemote . isBatching ( arg ) ;
if ( remote . isBatching ( arg ) ) remote . flush ( arg ) ;
if ( remote . isBatching ( arg ) ) remote . flush ( arg ) ;
if ( remote . isBatching ( arg ) ) remote . flush ( arg ) ;
if ( remote . isBatching ( arg ) ) remote . flush ( arg ) ;
if ( remote . isBatching ( arg ) ) remote . flush ( arg ) ;
if ( remote . isBatching ( arg ) ) remote . flush ( arg ) ;
FlushMode flushMode = entry . flushMode ;
boolean batch = true ;
if ( approxFrameLength > ( arg ) ) batch = false ;
if ( space <= 0 ) batch = false ;
if ( remote . isBatching ( arg ) ) remote . flush ( arg ) ;
if ( remote . isBatching ( arg ) ) remote . flush ( arg ) ;
if ( remote . isBatching ( arg ) ) remote . flush ( arg ) ;
if ( remote . isBatching ( arg ) ) remote . flush ( arg ) ;
if ( remote . isBatching ( arg ) ) remote . flush ( arg ) ;
if ( remote . isBatching ( arg ) ) remote . flush ( arg ) ;
if ( remote . isBatching ( arg ) ) remote . flush ( arg ) ;
if ( remote . isBatching ( arg ) ) remote . flush ( arg ) ;
if ( remote . isBatching ( arg ) ) remote . flush ( arg ) ;
if ( remote . isBatching ( arg ) ) remote . flush ( arg ) ;
if ( remote . isBatching ( arg ) ) remote . flush ( arg ) ;
if ( BufferUtil . hasContent ( arg ) ) aggregate . put ( arg ) ;
int space = aggregate == null ? bufferSize : aggregate . remaining ( arg ) ;
entry . genHeaderBytes ( arg ) ;
SPDYServerConnectionFactory . checkProtocolNegotiationAvailable ( arg ) ;
SPDYServerConnectionFactory . checkProtocolNegotiationAvailable ( arg ) ;
return getProtocols ( arg ) ;
SPDYServerConnectionFactory . checkProtocolNegotiationAvailable ( arg ) ;
SPDYServerConnectionFactory . checkNPNAvailable ( arg ) ;
SPDYServerConnectionFactory . checkNPNAvailable ( arg ) ;
SPDYServerConnectionFactory . checkNPNAvailable ( arg ) ;
SPDYServerConnectionFactory . checkNPNAvailable ( arg ) ;
SPDYServerConnectionFactory . checkNPNAvailable ( arg ) ;
SPDYServerConnectionFactory . checkNPNAvailable ( arg ) ;
_blocker . _lock . lock ( arg ) ;
_blocker . _lock . unlock ( arg ) ;
blocker . succeeded ( arg ) ;
blocker . failed ( arg ) ;
final String name = _thread . getName ( arg ) ;
Path homePath = homeDir . toPath ( arg ) . resolve ( arg ) ;
return baseDir . toFile ( arg ) ;
return homeDir . toFile ( arg ) ;
this . homeDir = homePath ;
if ( ! updateSenderState ( arg ) ) throw new IllegalStateException ( arg ) ;
if ( ! updateSenderState ( arg ) ) throw new IllegalStateException ( arg ) ;
if ( ! updateSenderState ( arg ) ) throw new IllegalStateException ( arg ) ;
FilterHolder holder = _filterHolders . get ( arg ) ;
ServletHolder jsp_pg_servlet = _servletHolders . get ( arg ) ;
_servletHolders . put ( arg ) ;
ServletHolder holder = _servletHolders . get ( arg ) ;
FilterHolder holder = _filterHolders . get ( arg ) ;
ServletHolder jsp_pg_servlet = _servletHolders . get ( arg ) ;
_servletHolders . put ( arg ) ;
ServletHolder holder = _servletHolders . get ( arg ) ;
if ( ! updateSenderState ( arg ) ) throw new IllegalStateException ( arg ) ;
if ( ! updateSenderState ( arg ) ) throw new IllegalStateException ( arg ) ;
if ( ! updateSenderState ( arg ) ) throw new IllegalStateException ( arg ) ;
copyTestDir ( arg ) ;
makeFile ( arg ) ;
copyTestDir ( arg ) ;
makeFile ( arg ) ;
makeFile ( arg ) ;
copyTestDir ( arg ) ;
makeFile ( arg ) ;
makeFile ( arg ) ;
copyTestDir ( arg ) ;
makeFile ( arg ) ;
makeFile ( arg ) ;
copyTestDir ( arg ) ;
makeFile ( arg ) ;
makeFile ( arg ) ;
copyTestDir ( arg ) ;
makeFile ( arg ) ;
copyTestDir ( arg ) ;
makeFile ( arg ) ;
copyTestDir ( arg ) ;
makeFile ( arg ) ;
copyTestDir ( arg ) ;
makeFile ( arg ) ;
makeFile ( arg ) ;
makeFile ( arg ) ;
copyTestDir ( arg ) ;
makeFile ( arg ) ;
makeFile ( arg ) ;
makeFile ( arg ) ;
copyTestDir ( arg ) ;
makeFile ( arg ) ;
makeFile ( arg ) ;
makeFile ( arg ) ;
makeFile ( arg ) ;
copyTestDir ( arg ) ;
makeFile ( arg ) ;
makeFile ( arg ) ;
makeFile ( arg ) ;
return baseDir . getDir ( arg ) . toFile ( arg ) ;
return homeDir . getDir ( arg ) . toFile ( arg ) ;
return homeDir . getDir ( arg ) . compareTo ( arg ) != 0 ;
this . baseDir . setDir ( arg ) ;
this . homeDir . setDir ( arg ) ;
LinkOption lopts [ ] = new LinkOption [ 0 ] ;
File file = basehome . getFile ( arg ) ;
return CMD_LINE_SOURCE ;
Path homePath = homeDir . toPath ( arg ) ;
basedir = getFile ( arg ) . getParentFile ( arg ) . toPath ( arg ) . toAbsolutePath ( arg ) ;
ProxyServlet . Transparent proxyServlet = new ProxyServlet . Transparent ( arg ) ;
_writeListener . onError ( arg ) ;
int requiredCapacity = buffer . capacity ( arg ) + length ;
String jspPackageName = ( String ) getServletHandler ( arg ) . getServletContext ( arg ) . getAttribute ( arg ) ;
Generator . Result result = generator . generateResponseContent ( arg ) ;
Generator . Result result = generator . generateResponseContent ( arg ) ;
writeListener = new StreamWriter ( arg ) ;
throw new BadMessage ( arg ) ;
return Action . IO_WAIT ;
NBitInteger . encode5 ( arg ) ;
NBitInteger . encode5 ( arg ) ;
NBitInteger . encode8 ( arg ) ;
headerParser . reset ( arg ) ;
return headerParser . isEndStream ( arg ) ;
return headerParser . isPaddingHigh ( arg ) ;
return headerParser . isPaddingLow ( arg ) ;
return listener . onDataFrame ( arg ) ;
return listener . onPriorityFrame ( arg ) ;
return listener . onResetFrame ( arg ) ;
return notifyDataFrame ( arg ) ;
return notifyPingFrame ( arg ) ? Result . ASYNC : Result . COMPLETE ;
return notifyResetFrame ( arg ) ? Result . ASYNC : Result . COMPLETE ;
Generator . Result result = generator . generateContent ( arg ) ;
state = State . PAYLOAD ;
state = State . EXCLUSIVE ;
state = State . ERROR ;
state = State . WINDOW_DELTA ;
if ( paddingLength > DataFrame . MAX_LENGTH - 3 ) throw new IllegalArgumentException ( arg ) ;
int dataBytesPerFrame = DataFrame . MAX_LENGTH - extraPaddingBytes - paddingLength ;
result = result . merge ( arg ) ;
Generator . Result result = generator . generateData ( arg ) ;
Generator . Result result = generator . generateGoAway ( arg ) ;
Generator . Result result = generator . generateGoAway ( arg ) ;
Generator . Result result = generator . generatePing ( arg ) ;
Generator . Result result = generator . generatePing ( arg ) ;
Generator . Result result = generator . generatePriority ( arg ) ;
Generator . Result result = generator . generatePriority ( arg ) ;
Generator . Result result = generator . generateReset ( arg ) ;
Generator . Result result = generator . generateReset ( arg ) ;
Generator . Result result = generator . generateSettings ( arg ) ;
Generator . Result result = generator . generateSettings ( arg ) ;
Generator . Result result = generator . generateWindowUpdate ( arg ) ;
Generator . Result result = generator . generateWindowUpdate ( arg ) ;
Path logfile = baseHome . getBasePath ( arg ) ;
_headerTableSize-= entry . getSize ( arg ) ;
Entry entry = ctx . getNameEntry ( arg ) ;
growUnsafe ( arg ) ;
if ( _static ) throw new IllegalStateException ( arg ) ;
return _static ;
int i = buf . get ( arg ) & nbits ;
_listener . emit ( arg ) ;
_listener . emit ( arg ) ;
_listener . emit ( arg ) ;
lease = lease . merge ( arg ) ;
huffman = __DO_NOT_HUFFMAN . contains ( arg ) ;
huffman = __DO_NOT_HUFFMAN . contains ( arg ) ;
_scheme = HttpScheme . valueOf ( arg ) ;
boolean huffman = ( buffer . get ( arg ) & 0x80 ) == 0x80 ;
if ( huffman ) name = Huffman . decode ( arg ) ;
boolean huffman = ( buffer . get ( arg ) & 0x80 ) == 0x80 ;
if ( huffman ) value = Huffman . decode ( arg ) ;
Integer code = Integer . getInteger ( arg ) ;
length-= 1 ;
AuthorityHttpField afield = ( field instanceof AuthorityHttpField ) ? ( ( AuthorityHttpField ) field ) : new AuthorityHttpField ( arg ) ;
List < HttpField > lm = m . getFields ( arg ) ;
List < HttpField > fields = requestMetaData . getFields ( arg ) ;
Queue < Generator . LeaseCallback > queued ;
Generator . LeaseCallback item = queued . poll ( arg ) ;
stalled . clear ( arg ) ;
return generateHeader ( arg ) ;
testGenerateParseSmallContent ( arg ) ;
Session . Listener listener = newSessionListener ( arg ) ;
HTTP2Connection connection = new HTTP2Connection ( arg ) ;
HTTP2FlowControl . LOG . debug ( arg ) ;
HTTP2FlowControl . LOG . debug ( arg ) ;
ByteBuffer header = generateHeader ( arg ) ;
SPDYServerConnectionFactory . checkProtocolNegotiationAvailable ( arg ) ;
SPDYServerConnectionFactory . checkProtocolNegotiationAvailable ( arg ) ;
SPDYServerConnectionFactory . checkProtocolNegotiationAvailable ( arg ) ;
HttpParser . RequestHandler < ByteBuffer > handler = new Handler ( arg ) ;
HttpParser . RequestHandler < ByteBuffer > handler = new Handler ( arg ) ;
T item = getNextContent ( arg ) ;
T item = getNextContent ( arg ) ;
T item = _inputQ . pollUnsafe ( arg ) ;
ByteBufferQueuedHttpInput input = new ByteBufferQueuedHttpInput ( arg ) ;
throw new BadMessage ( arg ) ;
throw new BadMessage ( arg ) ;
if ( ch <= HttpTokens . SPACE ) throw new BadMessage ( arg ) ;
throw new BadMessage ( arg ) ;
throw new BadMessage ( arg ) ;
if ( ! ( arg ) ) throw new BadMessage ( arg ) ;
throw new BadMessage ( arg ) ;
throw new BadMessage ( arg ) ;
throw new BadMessage ( arg ) ;
throw new BadMessage ( arg ) ;
return HTTP/2  + _status +  N + super . toString ( arg ) ;
authority = header . getValue ( arg ) ;
return _hostPort . getHost ( arg ) ;
return _hostPort . getPort ( arg ) ;
initialise . add ( arg ) ;
Session client = newClient ( arg ) ;
Session client = newClient ( arg ) ;
client . settings ( arg ) ;
Session client = newClient ( arg ) ;
Session client = newClient ( arg ) ;
for ( Session session : sessions ) session . close ( arg ) ;
if ( getRequest ( arg ) . getMethod ( arg ) == null ) _httpConnection . close ( arg ) ;
if ( s . getInitOrder ( arg ) != 0 ) out . tag ( arg ) ;
Response original0 = new Response ( arg ) ;
Response original1 = new Response ( arg ) ;
MetaData original0 = new MetaData ( arg ) ;
MetaData original1 = new MetaData ( arg ) ;
String content_type = _fields . getStringField ( arg ) ;
boolean stack = ( cause instanceof RuntimeException ) || ( cause instanceof Error ) || LOG . isDebugEnabled ( arg ) ;
DatabaseLoginServiceTestServer . createDB ( arg ) ;
return entry . _index >= _nextE ? _size - entry . _index + _nextE : _nextSlot - entry . _index ;
for ( int i = 0 ; i < _nextSlot ; i ++ ) ( ( Entry ) _elements [ i ] ) . _index = i ;
_path = new HttpURI ( arg ) ;
HttpURI uri = request . getURI ( arg ) ;
fromByteArray ( arg ) ;
fromByteArray ( arg ) ;
fromByteArray ( arg ) ;
fromByteArray ( arg ) ;
fromByteArray ( arg ) ;
fromByteArray ( arg ) ;
fromByteArray ( arg ) ;
return new FinalMetaData . Request ( arg ) ;
MetaData . Response metaData = new FinalMetaData . Response ( arg ) ;
MetaData . Response response = new FinalMetaData . Response ( arg ) ;
MetaData . Response metaData = new FinalMetaData . Response ( arg ) ;
MetaData . Response metaData = new FinalMetaData . Response ( arg ) ;
MetaData . Response metaData = new FinalMetaData . Response ( arg ) ;
MetaData . Response metaData = new FinalMetaData . Response ( arg ) ;
MetaData . Response metaData = new FinalMetaData . Response ( arg ) ;
MetaData . Response metaData = new FinalMetaData . Response ( arg ) ;
MetaData . Response metaData = new FinalMetaData . Response ( arg ) ;
MetaData . Response response = new FinalMetaData . Response ( arg ) ;
MetaData . Request metaData = new FinalMetaData . Request ( arg ) ;
MetaData . Request metaData = new FinalMetaData . Request ( arg ) ;
MetaData . Request metaData = new FinalMetaData . Request ( arg ) ;
MetaData . Request metaData = new FinalMetaData . Request ( arg ) ;
Response original0 = new FinalMetaData . Response ( arg ) ;
Response original1 = new FinalMetaData . Response ( arg ) ;
MetaData original0 = new FinalMetaData ( arg ) ;
MetaData original1 = new FinalMetaData ( arg ) ;
MetaData metaData = new FinalMetaData . Response ( arg ) ;
MetaData . Request metaData = new FinalMetaData . Request ( arg ) ;
MetaData . Request metaData = new FinalMetaData . Request ( arg ) ;
MetaData . Request metaData = new FinalMetaData . Request ( arg ) ;
if ( _method == null ) _httpConnection . close ( arg ) ;
_method = HttpMethod . CONNECT . asString ( arg ) ;
MetaData . Request request = new FinalMetaData . Request ( arg ) ;
request . setRequestURI ( arg ) ;
request . setRequestURI ( arg ) ;
_request . setRequestURI ( arg ) ;
_request . setRequestURI ( arg ) ;
_uri . setAuth ( arg ) ;
_uri . decodeQueryTo ( arg ) ;
_uri . decodeQueryTo ( arg ) ;
baseRequest . setURIPathQuery ( arg ) ;
_uri . setAuthority ( arg ) ;
if ( _parameters == null ) _parameters = restoreParameters ( arg ) ;
if ( _parameters == null ) _parameters = restoreParameters ( arg ) ;
if ( _parameters == null ) _parameters = restoreParameters ( arg ) ;
if ( _parameters == null ) _parameters = restoreParameters ( arg ) ;
HttpURI uri = baseRequest . getUri ( arg ) ;
for ( Exception failure : failures ) throw failure ;
int f = ( b & 0xF0 ) >> 4 ;
mask = ( byte ) 0x40 ;
mask = never_index ? ( byte ) 0x01 : ( byte ) 0x00 ;
mask = ( byte ) 0x00 ;
mask = ( byte ) 0x40 ;
int maxPayloadLength = Frame . MAX_LENGTH - fixedLength ;
if ( length > Frame . MAX_LENGTH ) throw new IllegalArgumentException ( arg ) ;
if ( length > Frame . MAX_LENGTH - fixedLength ) throw new IllegalArgumentException ( arg ) ;
int entryLength = 1 + 4 ;
if ( length > Frame . MAX_LENGTH ) throw new IllegalArgumentException ( arg ) ;
int flags = Flag . END_HEADERS ;
if ( r != null && r . getAlias ( arg ) != null &&! _context . checkAlias ( arg ) ) return null ;
return this . alias ;
return res . getAlias ( arg ) == null ;
if ( p >= 0 ) encoding = Indexed + index ;
name_bits = 6 ;
name_bits = 4 ;
name_bits = 4 ;
name_bits = 4 ;
name_bits = 6 ;
lease . prepend ( arg ) ;
String content_type = _metadata . getFields ( arg ) . getStringField ( arg ) ;
return _metadata == null ? null : _metadata . getFields ( arg ) . getStringField ( arg ) ;
attr . _pathInfo = _pathInfo ;
if ( cc != null ) _cacheControl = new CachedHttpField ( arg ) ;
FlusherEntry entry = new FlusherEntry ( arg ) ;
_defaultProtocol = defaultProtocol ;
HTTP2Session session = new HTTP2ClientSession ( arg ) ;
this . defaultProtocol = defaultProtocol ;
int sessionWindow = session . getWindowSize ( arg ) ;
streamWindow = stream . getWindowSize ( arg ) ;
if ( stream != null ) onUpdateWindowSize ( arg ) ;
onUpdateWindowSize ( arg ) ;
settings ( arg ) ;
String reason = tryConvertPayload ( arg ) ;
String referer = null ;
referer = field . getValue ( arg ) ;
if ( config . getInitParameter ( arg ) != null ) _associateDelay = Long . valueOf ( arg ) ;
closeLatch . countDown ( arg ) ;
closeLatch . countDown ( arg ) ;
_blocker . _lock . unlock ( arg ) ;
int old = _priorityDelta ;
if ( ! _complete . await ( arg ) ) _state = new BlockerTimeoutException ( arg ) ;
Thread . currentThread ( arg ) . getContextClassLoader ( arg ) . loadClass ( arg ) ;
Thread . currentThread ( arg ) . getContextClassLoader ( arg ) . loadClass ( arg ) ;
int requestId = getRequestId ( arg ) ;
if ( request . getInputStream ( arg ) . isReady ( arg ) ) onDataAvailable ( arg ) ;
int requestId = getRequestId ( arg ) ;
if ( request . getInputStream ( arg ) . isReady ( arg ) ) onDataAvailable ( arg ) ;
return _writeblock . acquire ( arg ) ;
if ( current == State . SELECTING ) setKeyInterests ( arg ) ;
if ( current == State . SELECTING ) _selector . wakeup ( arg ) ;
if ( selecting ) setKeyInterests ( arg ) ;
out . setFilter ( arg ) ;
out . setFilter ( arg ) ;
for ( String m : methods ) _methods . add ( arg ) ;
return _methods . toArray ( arg ) ;
_methods . clear ( arg ) ;
tester . getGzipHandler ( arg ) . setVary ( arg ) ;
tester . getGzipHandler ( arg ) . setVary ( arg ) ;
tester . getGzipHandler ( arg ) . setVary ( arg ) ;
server . configureHandlers ( arg ) ;
server . addWebApplication ( arg ) ;
server . addWebApplication ( arg ) ;
return ( arg ) && ( defaultConfig . size ( arg ) > 0 ) ;
return ( arg ) && ( defaultConfig . size ( arg ) > 0 ) ;
FilterHolder holder = tester . setContentServlet ( arg ) ;
FilterHolder holder = tester . setContentServlet ( arg ) ;
HttpTester . Response response = tester . issueRequest ( arg ) ;
HttpTester . Response response = tester . issueRequest ( arg ) ;
HttpTester . Response response = tester . issueRequest ( arg ) ;
HttpTester . Response response = tester . issueRequest ( arg ) ;
HttpTester . Response response = tester . issueRequest ( arg ) ;
HttpTester . Response http = tester . assertIsResponseNotGzipCompressed ( arg ) ;
HttpTester . Response http = tester . assertIsResponseNotGzipCompressed ( arg ) ;
if ( dft == null &&! protocols . isEmpty ( arg ) ) dft = protocols . get ( arg ) ;
via = Main . join ( arg ) ;
List < Module > active = resolveEnabled ( arg ) ;
enableModule ( arg ) ;
enableModule ( arg ) ;
return license != null && license . size ( arg ) > 0 ;
this . logicalName = this . fileRef ;
return ! logicalName . equals ( arg ) ;
logicalName = line ;
Set < String > startDNames = new HashSet <> ( arg ) ;
Set < String > startIniNames = new HashSet <> ( arg ) ;
Set < String > resolvedParents = new HashSet <> ( arg ) ;
Set < String > parentNames = new HashSet <> ( arg ) ;
File basePath = testdir . getEmptyDir ( arg ) ;
File basePath = testdir . getEmptyDir ( arg ) ;
File basePath = testdir . getEmptyDir ( arg ) ;
File basePath = testdir . getEmptyDir ( arg ) ;
assertFileExists ( arg ) ;
File basePath = testdir . getEmptyDir ( arg ) ;
assertFileExists ( arg ) ;
proxyConnector . getConnectionFactory ( arg ) . getHttpConfiguration ( arg ) . setDelayDispatchOnContent ( arg ) ;
_connector . getConnectionFactory ( arg ) . getHttpConfiguration ( arg ) . setDelayDispatchOnContent ( arg ) ;
List < Module > activeModules = modules . getEnabled ( arg ) ;
List < Module > enabled = modules . getEnabled ( arg ) ;
List < Module > active = getEnabled ( arg ) ;
List < T > active = getEnabled ( arg ) ;
List < T > active = getEnabled ( arg ) ;
List < Module > active = modules . getEnabled ( arg ) ;
List < Module > active = modules . getEnabled ( arg ) ;
List < Module > active = modules . getEnabled ( arg ) ;
int slot = _headerTable . getNextSlotUnsafe ( arg ) ;
_headerTableSizeInBytes-= entry . getSize ( arg ) ;
Entry e = __headerEntryTable [ header . ordinal ( arg ) ] ;
return _headerTableSizeInBytes ;
return __headerEntryTable [ header . ordinal ( arg ) ] ;
return _headerTable . index ( arg ) + __staticTable . length - 1 ;
_headerTable . resizeUnsafe ( arg ) ;
return _headerTable . size ( arg ) ;
if ( size > _localMaxHeaderTableSize ) throw new IllegalArgumentException ( arg ) ;
_localMaxHeaderTableSize = localMaxHeaderTableSize ;
_remoteMaxHeaderTableSize = remoteMaxHeaderTableSize ;
hpackEncoder . setRemoteMaxHeaderTableSize ( arg ) ;
this . maxHeaderTableSize = maxHeaderTableSize ;
ALPN . debug = true ;
complete = task == null || _producer . isMoreToProduce ( arg ) ;
if ( _producer . isMoreToProduce ( arg ) ) _executor . execute ( arg ) ;
boolean dispatchFailure = isDispatchIO ( arg ) && NonBlockingThread . isNonBlockingThread ( arg ) ;
return _priorityDelta ;
return _dispatchIO ;
notifyConnect ( arg ) ;
Stream stream = getHttp2Transport ( arg ) . getStream ( arg ) ;
Stream stream = getHttp2Transport ( arg ) . getStream ( arg ) ;
Stream stream = getHttp2Transport ( arg ) . getStream ( arg ) ;
getHttp2Transport ( arg ) . recycle ( arg ) ;
Stream stream = getHttp2Transport ( arg ) . getStream ( arg ) ;
executionStrategy . produce ( arg ) ;
while ( arg ) _strategy . produce ( arg ) ;
if ( finished ) _channelState . onReadPossible ( arg ) ;
error = _onError ;
Content item = getNextContent ( arg ) ;
_channelState . onReadPossible ( arg ) ;
onReadPossible ( arg ) ;
_notReady = false ;
_httpConnection . _generator . setPersistent ( arg ) ;
_httpConnection . _generator . setPersistent ( arg ) ;
_httpConnection . _generator . setPersistent ( arg ) ;
if ( ! persistent ) _httpConnection . _generator . setPersistent ( arg ) ;
ByteBuffer requestBuffer = getRequestBuffer ( arg ) ;
getFillInterest ( arg ) . fillable ( arg ) ;
p = buffer . length ( arg ) - p - 28 ;
p = buffer . length ( arg ) - p - 18 ;
while ( arg ) _strategy . execute ( arg ) ;
if ( suspended || getEndPoint ( arg ) . getConnection ( arg ) != this || handling ) break ;
_httpConnection . fillInterested ( arg ) ;
boolean had_input = BufferUtil . hasContent ( arg ) ;
