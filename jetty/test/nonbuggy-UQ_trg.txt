if ( ! leakDetector . acquired ( arg ) ) LOG . warn ( arg ) ;
if ( ! leakDetector . released ( arg ) ) LOG . warn ( arg ) ;
syncTimeoutTask . cancel ( arg ) ;
asyncTimeoutTask . cancel ( arg ) ;
return jettyRemote . isBatching ( arg ) ;
jettyRemote . setBatching ( arg ) ;
return jettyRemote . getBatchMode ( arg ) == BatchMode . ON ;
if ( remote . getBatchMode ( arg ) == BatchMode . ON ) remote . flush ( arg ) ;
if ( remote . getBatchMode ( arg ) == BatchMode . ON ) remote . flush ( arg ) ;
if ( remote . getBatchMode ( arg ) == BatchMode . ON ) remote . flush ( arg ) ;
if ( remote . getBatchMode ( arg ) == BatchMode . ON ) remote . flush ( arg ) ;
if ( remote . getBatchMode ( arg ) == BatchMode . ON ) remote . flush ( arg ) ;
if ( remote . getBatchMode ( arg ) == BatchMode . ON ) remote . flush ( arg ) ;
BatchMode batchMode = entry . batchMode ;
BatchMode currentBatchMode = BatchMode . AUTO ;
if ( approxFrameLength > ( arg ) ) currentBatchMode = BatchMode . OFF ;
if ( space <= 0 ) currentBatchMode = BatchMode . OFF ;
if ( remote . getBatchMode ( arg ) == BatchMode . ON ) remote . flush ( arg ) ;
if ( remote . getBatchMode ( arg ) == BatchMode . ON ) remote . flush ( arg ) ;
if ( remote . getBatchMode ( arg ) == BatchMode . ON ) remote . flush ( arg ) ;
if ( remote . getBatchMode ( arg ) == BatchMode . ON ) remote . flush ( arg ) ;
if ( remote . getBatchMode ( arg ) == BatchMode . ON ) remote . flush ( arg ) ;
if ( remote . getBatchMode ( arg ) == BatchMode . ON ) remote . flush ( arg ) ;
if ( remote . getBatchMode ( arg ) == BatchMode . ON ) remote . flush ( arg ) ;
if ( remote . getBatchMode ( arg ) == BatchMode . ON ) remote . flush ( arg ) ;
if ( remote . getBatchMode ( arg ) == BatchMode . ON ) remote . flush ( arg ) ;
if ( remote . getBatchMode ( arg ) == BatchMode . ON ) remote . flush ( arg ) ;
if ( remote . getBatchMode ( arg ) == BatchMode . ON ) remote . flush ( arg ) ;
if ( BufferUtil . hasContent ( arg ) ) BufferUtil . append ( arg ) ;
int space = aggregate == null ? bufferSize : BufferUtil . space ( arg ) ;
entry . generateHeaderBytes ( arg ) ;
SPDYServerConnectionFactory . checkNPNAvailable ( arg ) ;
SPDYServerConnectionFactory . checkNPNAvailable ( arg ) ;
return protocols ;
SPDYServerConnectionFactory . checkNPNAvailable ( arg ) ;
SPDYServerConnectionFactory . checkProtocolNegotiationAvailable ( arg ) ;
SPDYServerConnectionFactory . checkProtocolNegotiationAvailable ( arg ) ;
SPDYServerConnectionFactory . checkProtocolNegotiationAvailable ( arg ) ;
SPDYServerConnectionFactory . checkProtocolNegotiationAvailable ( arg ) ;
SPDYServerConnectionFactory . checkProtocolNegotiationAvailable ( arg ) ;
SPDYServerConnectionFactory . checkProtocolNegotiationAvailable ( arg ) ;
_lock . lock ( arg ) ;
_lock . unlock ( arg ) ;
fcb . succeeded ( arg ) ;
fcb . failed ( arg ) ;
String name = _thread . getName ( arg ) ;
Path homePath = homeDir . resolve ( arg ) ;
return baseDir . getDir ( arg ) . toFile ( arg ) ;
return homeDir . getDir ( arg ) . toFile ( arg ) ;
this . homeDir . setDir ( arg ) ;
if ( ! updateSenderState ( arg ) ) throw illegalSenderState ( arg ) ;
if ( ! updateSenderState ( arg ) ) throw illegalSenderState ( arg ) ;
if ( ! updateSenderState ( arg ) ) throw illegalSenderState ( arg ) ;
FilterHolder holder = _filterHolderMap . get ( arg ) ;
ServletHolder jsp_pg_servlet = _servletHolderMap . get ( arg ) ;
_servletHolderMap . put ( arg ) ;
ServletHolder holder = _servletHolderMap . get ( arg ) ;
FilterHolder holder = _filterHolderMap . get ( arg ) ;
ServletHolder jsp_pg_servlet = _servletHolderMap . get ( arg ) ;
_servletHolderMap . put ( arg ) ;
ServletHolder holder = _servletHolderMap . get ( arg ) ;
if ( ! updateSenderState ( arg ) ) throw illegalSenderState ( arg ) ;
if ( ! updateSenderState ( arg ) ) throw illegalSenderState ( arg ) ;
if ( ! updateSenderState ( arg ) ) throw illegalSenderState ( arg ) ;
TestEnv . copyTestDir ( arg ) ;
TestEnv . makeFile ( arg ) ;
TestEnv . copyTestDir ( arg ) ;
TestEnv . makeFile ( arg ) ;
TestEnv . makeFile ( arg ) ;
TestEnv . copyTestDir ( arg ) ;
TestEnv . makeFile ( arg ) ;
TestEnv . makeFile ( arg ) ;
TestEnv . copyTestDir ( arg ) ;
TestEnv . makeFile ( arg ) ;
TestEnv . makeFile ( arg ) ;
TestEnv . copyTestDir ( arg ) ;
TestEnv . makeFile ( arg ) ;
TestEnv . makeFile ( arg ) ;
TestEnv . copyTestDir ( arg ) ;
TestEnv . makeFile ( arg ) ;
TestEnv . copyTestDir ( arg ) ;
TestEnv . makeFile ( arg ) ;
TestEnv . copyTestDir ( arg ) ;
TestEnv . makeFile ( arg ) ;
TestEnv . copyTestDir ( arg ) ;
TestEnv . makeFile ( arg ) ;
TestEnv . makeFile ( arg ) ;
TestEnv . makeFile ( arg ) ;
TestEnv . copyTestDir ( arg ) ;
TestEnv . makeFile ( arg ) ;
TestEnv . makeFile ( arg ) ;
TestEnv . makeFile ( arg ) ;
TestEnv . copyTestDir ( arg ) ;
TestEnv . makeFile ( arg ) ;
TestEnv . makeFile ( arg ) ;
TestEnv . makeFile ( arg ) ;
TestEnv . makeFile ( arg ) ;
TestEnv . copyTestDir ( arg ) ;
TestEnv . makeFile ( arg ) ;
TestEnv . makeFile ( arg ) ;
TestEnv . makeFile ( arg ) ;
return baseDir . toFile ( arg ) ;
return homeDir . toFile ( arg ) ;
return homeDir . compareTo ( arg ) != 0 ;
this . baseDir = dir . toAbsolutePath ( arg ) ;
this . homeDir = dir . toAbsolutePath ( arg ) ;
LinkOption lopts [ ] = NO_LINK_OPTIONS ;
Path file = basehome . getPath ( arg ) ;
return ORIGIN_CMD_LINE ;
Path homePath = homeDir . toPath ( arg ) . toAbsolutePath ( arg ) ;
basedir = getFile ( arg ) . getParent ( arg ) . toAbsolutePath ( arg ) ;
proxyServlet = new ProxyServlet . Transparent ( arg ) ;
_onError = e ;
int requiredCapacity = buffer == null ? 0 : buffer . capacity ( arg ) + length ;
String jspPackageName = ( String ) getServletHandler ( arg ) . getServletContext ( arg ) . getInitParameter ( arg ) ;
Generator . Result result = generateResponseContent ( arg ) ;
Generator . Result result = generateResponseContent ( arg ) ;
writeListener = newWriteListener ( arg ) ;
throw new IllegalStateException ( arg ) ;
return Action . WAIT ;
NBitInteger . encode ( arg ) ;
NBitInteger . encode ( arg ) ;
NBitInteger . encode ( arg ) ;
super . reset ( arg ) ;
return headerParser . hasFlag ( arg ) ;
return headerParser . hasFlag ( arg ) ;
return headerParser . hasFlag ( arg ) ;
return listener . onData ( arg ) ;
return listener . onPriority ( arg ) ;
return listener . onReset ( arg ) ;
return notifyData ( arg ) ;
return notifyPing ( arg ) ? Result . ASYNC : Result . COMPLETE ;
return notifyReset ( arg ) ? Result . ASYNC : Result . COMPLETE ;
Generator . Result result = generator . generateData ( arg ) ;
state = State . PREPARE ;
state = State . PREPARE ;
state = State . PREPARE ;
state = State . PREPARE ;
if ( paddingLength > Frame . MAX_LENGTH - 3 ) throw new IllegalArgumentException ( arg ) ;
int dataBytesPerFrame = Frame . MAX_LENGTH - extraPaddingBytes - paddingLength ;
lease = lease . merge ( arg ) ;
ByteBufferPool . Lease lease = generator . generateData ( arg ) ;
ByteBufferPool . Lease lease = generator . generateGoAway ( arg ) ;
ByteBufferPool . Lease lease = generator . generateGoAway ( arg ) ;
ByteBufferPool . Lease lease = generator . generatePing ( arg ) ;
ByteBufferPool . Lease lease = generator . generatePing ( arg ) ;
ByteBufferPool . Lease lease = generator . generatePriority ( arg ) ;
ByteBufferPool . Lease lease = generator . generatePriority ( arg ) ;
ByteBufferPool . Lease lease = generator . generateReset ( arg ) ;
ByteBufferPool . Lease lease = generator . generateReset ( arg ) ;
ByteBufferPool . Lease lease = generator . generateSettings ( arg ) ;
ByteBufferPool . Lease lease = generator . generateSettings ( arg ) ;
ByteBufferPool . Lease lease = generator . generateWindowUpdate ( arg ) ;
ByteBufferPool . Lease lease = generator . generateWindowUpdate ( arg ) ;
Path logfile = baseHome . getPath ( arg ) ;
_headerTableSizeInBytes-= entry . getSize ( arg ) ;
Entry entry = ctx . get ( arg ) ;
resizeUnsafe ( arg ) ;
if ( isStatic ( arg ) ) throw new IllegalStateException ( arg ) ;
return false ;
int i = buffer . get ( arg ) & nbits ;
_builder . emit ( arg ) ;
_builder . emit ( arg ) ;
_builder . emit ( arg ) ;
generator . generateData ( arg ) ;
huffman =! __DO_NOT_HUFFMAN . contains ( arg ) ;
huffman =! __DO_NOT_HUFFMAN . contains ( arg ) ;
_scheme = HttpScheme . CACHE . get ( arg ) ;
huffmanName = ( buffer . get ( arg ) & 0x80 ) == 0x80 ;
if ( huffmanName ) name = Huffman . decode ( arg ) ;
boolean huffmanValue = ( buffer . get ( arg ) & 0x80 ) == 0x80 ;
if ( huffmanValue ) value = Huffman . decode ( arg ) ;
Integer code = Integer . valueOf ( arg ) ;
-- length ;
HostPortHttpField afield = ( field instanceof HostPortHttpField ) ? ( ( HostPortHttpField ) field ) : new AuthorityHttpField ( arg ) ;
HttpFields lm = m . getFields ( arg ) ;
HttpFields fields = requestMetaData . getFields ( arg ) ;
Queue < FlusherEntry > queued ;
FlusherEntry item = queued . poll ( arg ) ;
streams . clear ( arg ) ;
return headerGenerator . generate ( arg ) ;
testGenerateParseContent ( arg ) ;
ServerSessionListener listener = newSessionListener ( arg ) ;
HTTP2Connection connection = new HTTP2ServerConnection ( arg ) ;
flowControl . onSessionStalled ( arg ) ;
flowControl . onStreamStalled ( arg ) ;
ByteBuffer header = headerGenerator . generate ( arg ) ;
NegotiatingServerConnectionFactory . checkProtocolNegotiationAvailable ( arg ) ;
NegotiatingServerConnectionFactory . checkProtocolNegotiationAvailable ( arg ) ;
NegotiatingServerConnectionFactory . checkProtocolNegotiationAvailable ( arg ) ;
HttpParser . RequestHandler handler = new Handler ( arg ) ;
HttpParser . RequestHandler handler = new Handler ( arg ) ;
Content item = getNextContent ( arg ) ;
Content item = getNextContent ( arg ) ;
Content item = _inputQ . pollUnsafe ( arg ) ;
QueuedHttpInput input = new QueuedHttpInput ( arg ) ;
throw new BadMessageException ( arg ) ;
throw new BadMessageException ( arg ) ;
if ( ch <= HttpTokens . SPACE ) throw new BadMessageException ( arg ) ;
throw new BadMessageException ( arg ) ;
throw new BadMessageException ( arg ) ;
if ( ! ( arg ) ) throw new BadMessageException ( arg ) ;
throw new BadMessageException ( arg ) ;
throw new BadMessageException ( arg ) ;
throw new BadMessageException ( arg ) ;
throw new BadMessageException ( arg ) ;
return String . format ( arg ) ;
hostPort = new HostPortHttpField ( arg ) ;
return _hostPort == null ? null : _hostPort . getHost ( arg ) ;
return _hostPort == null ? 0 : _hostPort . getPort ( arg ) ;
defaultConfig . add ( arg ) ;
Session session = newClient ( arg ) ;
Session session = newClient ( arg ) ;
session . settings ( arg ) ;
Session session = newClient ( arg ) ;
Session session = newClient ( arg ) ;
for ( ISession session : sessions ) session . close ( arg ) ;
if ( _method == null ) _httpConnection . close ( arg ) ;
if ( s . getInitOrder ( arg ) >= 0 ) out . tag ( arg ) ;
Response original0 = new FinalMetaData . Response ( arg ) ;
Response original1 = new FinalMetaData . Response ( arg ) ;
MetaData original0 = new FinalMetaData ( arg ) ;
MetaData original1 = new FinalMetaData ( arg ) ;
String content_type = _metadata . getFields ( arg ) . getStringField ( arg ) ;
boolean stack = LOG . isDebugEnabled ( arg ) || ( ! ( cause instanceof NumberFormatException ) && ( cause instanceof RuntimeException || cause instanceof Error ) ) ;
_dbRoot = DatabaseLoginServiceTestServer . createDB ( arg ) ;
return entry . _slot >= _nextE ? _size - entry . _slot + _nextE : _nextSlot - entry . _slot ;
for ( int s = 0 ; s < _nextSlot ; s ++ ) ( ( Entry ) _elements [ s ] ) . _slot = s ;
_path = field . getValue ( arg ) ;
HttpURI uri = new HttpURI ( arg ) ;
fromString ( arg ) ;
fromString ( arg ) ;
fromString ( arg ) ;
fromString ( arg ) ;
fromString ( arg ) ;
fromString ( arg ) ;
fromString ( arg ) ;
return new MetaData . Request ( arg ) ;
MetaData . Response metaData = new MetaData . Response ( arg ) ;
MetaData . Response response = new MetaData . Response ( arg ) ;
MetaData . Response metaData = new MetaData . Response ( arg ) ;
MetaData . Response metaData = new MetaData . Response ( arg ) ;
MetaData . Response metaData = new MetaData . Response ( arg ) ;
MetaData . Response metaData = new MetaData . Response ( arg ) ;
MetaData . Response metaData = new MetaData . Response ( arg ) ;
MetaData . Response metaData = new MetaData . Response ( arg ) ;
MetaData . Response metaData = new MetaData . Response ( arg ) ;
MetaData . Response response = new MetaData . Response ( arg ) ;
MetaData . Request metaData = new MetaData . Request ( arg ) ;
MetaData . Request metaData = new MetaData . Request ( arg ) ;
MetaData . Request metaData = new MetaData . Request ( arg ) ;
MetaData . Request metaData = new MetaData . Request ( arg ) ;
Response original0 = new MetaData . Response ( arg ) ;
Response original1 = new MetaData . Response ( arg ) ;
MetaData original0 = new MetaData ( arg ) ;
MetaData original1 = new MetaData ( arg ) ;
MetaData metaData = new MetaData . Response ( arg ) ;
MetaData . Request metaData = new MetaData . Request ( arg ) ;
MetaData . Request metaData = new MetaData . Request ( arg ) ;
MetaData . Request metaData = new MetaData . Request ( arg ) ;
if ( _metadata . getMethod ( arg ) == null ) _httpConnection . close ( arg ) ;
_metadata . setMethod ( arg ) ;
MetaData . Request request = new MetaData . Request ( arg ) ;
request . setURIPathQuery ( arg ) ;
request . setURIPathQuery ( arg ) ;
_request . setURIPathQuery ( arg ) ;
_request . setURIPathQuery ( arg ) ;
_uri . setAuthority ( arg ) ;
_metadata . getURI ( arg ) . decodeQueryTo ( arg ) ;
_metadata . getURI ( arg ) . decodeQueryTo ( arg ) ;
baseRequest . setHttpURI ( arg ) ;
_metadata . getURI ( arg ) . setAuthority ( arg ) ;
if ( _parameters == null ) restoreParameters ( arg ) ;
if ( _parameters == null ) restoreParameters ( arg ) ;
if ( _parameters == null ) restoreParameters ( arg ) ;
if ( _parameters == null ) restoreParameters ( arg ) ;
HttpURI uri = baseRequest . getHttpURI ( arg ) ;
for ( Throwable failure : failures ) throw failure ;
byte f = ( byte ) ( ( b & 0xF0 ) >> 4 ) ;
buffer . put ( arg ) ;
buffer . put ( arg ) ;
buffer . put ( arg ) ;
buffer . put ( arg ) ;
int maxPayloadLength = Frame . DEFAULT_MAX_LENGTH - fixedLength ;
if ( length > maxFrameSize ) throw new IllegalArgumentException ( arg ) ;
if ( length > maxFrameSize - fixedLength ) throw new IllegalArgumentException ( arg ) ;
int entryLength = 2 + 4 ;
if ( length > getMaxFrameSize ( arg ) ) throw new IllegalArgumentException ( arg ) ;
int flags = Flags . END_HEADERS ;
if ( r != null && r . isAlias ( arg ) &&! _context . checkAlias ( arg ) ) return null ;
return this . alias == null ? null : this . alias . toUri ( arg ) ;
return ! res . isAlias ( arg ) ;
if ( p >= 0 ) encoding = IdxField + ( entry . isStatic ( arg ) ? S :  ) + ( 1 + NBitInteger . octectsNeeded ( arg ) ) ;
bits = 6 ;
bits = 4 ;
bits = 4 ;
bits = 4 ;
bits = 6 ;
lease . insert ( arg ) ;
String content_type = _metadata . getFields ( arg ) . get ( arg ) ;
return _metadata == null ? null : _metadata . getFields ( arg ) . get ( arg ) ;
attr . _pathInfo = _pathInContext ;
if ( cc != null ) _cacheControl = new PreEncodedHttpField ( arg ) ;
ControlEntry entry = new ControlEntry ( arg ) ;
_defaultProtocol = StringUtil . asciiToLowerCase ( arg ) ;
HTTP2ClientSession session = new HTTP2ClientSession ( arg ) ;
this . defaultProtocol = defaultProtocol . trim ( arg ) ;
int sessionWindow = session . getSendWindow ( arg ) ;
streamWindow = stream . getSendWindow ( arg ) ;
if ( stream != null ) onWindowUpdate ( arg ) ;
onWindowUpdate ( arg ) ;
control ( arg ) ;
String reason = frame . tryConvertPayload ( arg ) ;
String referrer = null ;
referrer = field . getValue ( arg ) ;
if ( config . getInitParameter ( arg ) != null ) _associatePeriod = Long . valueOf ( arg ) ;
if ( session . isClosed ( arg ) && ( arg ) . isDisconnected ( arg ) ) closeLatch . countDown ( arg ) ;
if ( session . isClosed ( arg ) && ( arg ) . isDisconnected ( arg ) ) closeLatch . countDown ( arg ) ;
_lock . unlock ( arg ) ;
int oldDelta = _priorityDelta ;
if ( ! _complete . await ( idle + idle
Loader . loadClass ( arg ) ;
Loader . loadClass ( arg ) ;
int requestId = 0 ;
onDataAvailable ( arg ) ;
int requestId = 0 ;
onDataAvailable ( arg ) ;
return _writeBlock . acquire ( arg ) ;
if ( selecting ) setKeyInterests ( arg ) ;
if ( selecting ) _selector . wakeup ( arg ) ;
if ( current == State . UPDATED ) _selector . submit ( arg ) ;
out . setInterceptor ( arg ) ;
out . setInterceptor ( arg ) ;
for ( String m : methods ) _includedMethods . add ( arg ) ;
return _includedMethods . toArray ( arg ) ;
_includedMethods . clear ( arg ) ;
tester . getGzipHandler ( arg ) . setExcludedAgentPatterns ( arg ) ;
tester . getGzipHandler ( arg ) . setExcludedAgentPatterns ( arg ) ;
tester . getGzipHandler ( arg ) . setExcludedAgentPatterns ( arg ) ;
ServerSupport . configureHandlers ( arg ) ;
ServerSupport . addWebApplication ( arg ) ;
ServerSupport . addWebApplication ( arg ) ;
return hasDefaultConfig ;
return hasDefaultConfig ;
@ SuppressWarnings ( arg ) FilterHolder holder = tester . setContentServlet ( arg ) ;
@ SuppressWarnings ( arg ) FilterHolder holder = tester . setContentServlet ( arg ) ;
HttpTester . Response response = tester . executeRequest ( arg ) ;
HttpTester . Response response = tester . executeRequest ( arg ) ;
HttpTester . Response response = tester . executeRequest ( arg ) ;
HttpTester . Response response = tester . executeRequest ( arg ) ;
HttpTester . Response response = tester . executeRequest ( arg ) ;
HttpTester . Response http = assertIsResponseNotGzipCompressed ( arg ) ;
HttpTester . Response http = assertIsResponseNotGzipCompressed ( arg ) ;
if ( dft == null &&! negotiated . isEmpty ( arg ) ) dft = negotiated . get ( arg ) ;
via = Utils . join ( arg ) ;
List < Module > active = getEnabled ( arg ) ;
count += enableModule ( arg ) ;
count += enableModule ( arg ) ;
return ( arg ) && ( license . size ( arg ) > 0 ) ;
setName ( arg ) ;
return ! getName ( arg ) . equals ( arg ) ;
setName ( arg ) ;
List < String > startDNames = new ArrayList <> ( arg ) ;
List < String > startIniNames = new ArrayList <> ( arg ) ;
List < String > resolvedParents = new ArrayList <> ( arg ) ;
List < String > parentNames = new ArrayList <> ( arg ) ;
Path basePath = testdir . getEmptyDir ( arg ) . toPath ( arg ) ;
Path basePath = testdir . getEmptyDir ( arg ) . toPath ( arg ) ;
Path basePath = testdir . getEmptyDir ( arg ) . toPath ( arg ) ;
Path basePath = testdir . getEmptyDir ( arg ) . toPath ( arg ) ;
assertThat ( arg ) ;
Path basePath = testdir . getEmptyDir ( arg ) . toPath ( arg ) ;
assertThat ( arg ) ;
proxyConnector . getConnectionFactory ( arg ) . getHttpConfiguration ( arg ) . setDelayDispatchUntilContent ( arg ) ;
_connector . getConnectionFactory ( arg ) . getHttpConfiguration ( arg ) . setDelayDispatchUntilContent ( arg ) ;
List < Module > activeModules = modules . getSelected ( arg ) ;
List < Module > enabled = modules . getSelected ( arg ) ;
List < Module > active = getSelected ( arg ) ;
List < T > active = getSelected ( arg ) ;
List < T > active = getSelected ( arg ) ;
List < Module > active = modules . getSelected ( arg ) ;
List < Module > active = modules . getSelected ( arg ) ;
List < Module > active = modules . getSelected ( arg ) ;
int slot = _dynamicTable . getNextSlotUnsafe ( arg ) ;
_dynamicTableSizeInBytes-= entry . getSize ( arg ) ;
Entry e = __staticTableByHeader [ header . ordinal ( arg ) ] ;
return _dynamicTableSizeInBytes ;
return __staticTableByHeader [ header . ordinal ( arg ) ] ;
return _dynamicTable . index ( arg ) + __staticTable . length - 1 ;
_dynamicTable . resizeUnsafe ( arg ) ;
return _dynamicTable . size ( arg ) ;
if ( size > _localMaxDynamicTableSize ) throw new IllegalArgumentException ( arg ) ;
_localMaxDynamicTableSize = localMaxHeaderTableSize ;
_remoteMaxDynamicTableSize = remoteMaxHeaderTableSize ;
hpackEncoder . setRemoteMaxDynamicTableSize ( arg ) ;
this . maxDynamicTableSize = maxHeaderTableSize ;
ALPN . debug = false ;
complete = task == null || _producer . isMore ( arg ) ;
if ( _producer . isMore ( arg ) ) _executor . execute ( arg ) ;
boolean dispatchFailure = isDispatchIO ( arg ) ;
return 0 ;
return false ;
notifyAccept ( arg ) ;
Stream stream = getStream ( arg ) ;
Stream stream = getStream ( arg ) ;
Stream stream = getStream ( arg ) ;
getHttpTransport ( arg ) . recycle ( arg ) ;
Stream stream = getStream ( arg ) ;
executionStrategy . execute ( arg ) ;
while ( arg ) _strategy . execute ( arg ) ;
if ( finished ) onReadPossible ( arg ) ;
error = _state instanceof ErrorState ? ( ( ErrorState ) _state ) . getError ( arg ) : null ;
Content item = nextContent ( arg ) ;
onReadPossible ( arg ) ;
if ( needReadCB ) onReadPossible ( arg ) ;
_unready = false ;
_httpConnection . getGenerator ( arg ) . setPersistent ( arg ) ;
_httpConnection . getGenerator ( arg ) . setPersistent ( arg ) ;
_httpConnection . getGenerator ( arg ) . setPersistent ( arg ) ;
if ( ! persistent ) _httpConnection . getGenerator ( arg ) . setPersistent ( arg ) ;
if ( LOG . isDebugEnabled ( arg ) ) LOG . debug ( arg ) ;
if ( ! _closed && _in != null ) getFillInterest ( arg ) . fillable ( arg ) ;
p = buffer . length ( arg ) - p - 25 ;
p = buffer . length ( arg ) - p - 20 ;
_strategy . execute ( arg ) ;
if ( suspended || getEndPoint ( arg ) . getConnection ( arg ) != this ) break ;
_httpConnection . asyncReadFillInterested ( arg ) ;
boolean buffer_had_content = BufferUtil . hasContent ( arg ) ;
